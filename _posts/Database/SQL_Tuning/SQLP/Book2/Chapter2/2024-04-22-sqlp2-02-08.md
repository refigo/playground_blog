---
title: <오라클 성능 고도화 원리와 해법2> Ch02-08 고급 조인 테크닉
date: 2024-04-22
categories: [Database, SQL Tuning]
tags: [SQLP]
---

## 오라클 성능 고도화 원리와 해법2 - Ch02-08 고급 조인 테크닉

### (1) 누적 매출 구하기

우선 아래와 같이 월별 지점 매출 테이블을 만들어보자(스크립트 ch2_11.txt 참조)

```sql
create table 월별지점매출 as
select deptno as "지점",
       row_number() over (partition by deptno order by empno) as "판매월",
       round(dbms_random.value(500, 1000)) as "매출"
from emp
order by deptno;
```

그림 2-23 좌측은 방금 만든 월별 지점 매출 테이블을 출력한 것이다.

![](/assets/images/sqlp/sqlp2-02-08-1-img2-23.png)

이제 월별 지점 매출을 이용해 그림 2-23 우측과 같은 형태의 누적 매출을 구하려고 한다. 각 지점 별로 판매 월과 함께 증가하는 누적 매출(running total)을 구하려는 것이다.

오라클 8i부터 제공되기 시작한 분석 함수(Analytic Function)를 이용하면 아래와 같이 간단하게 원하는 결과를 얻을 수 있다.

```sql
select 지점, 판매월, 매출,
       Sum(매출) over (partition by 지점 order by 판매월 range between unbounded preceding and current row) as 누적매출
from 월별지점매출;
```

만약 분석 함수가 지원되지 않는 오라클 버전(또는 DBMS)을 사용하고 있다면 어떻게 해야 할까?

우리는 늘 ' = ' 연산자를 이용한 조인에만 익숙해져 있지만 업무에 따라서는 between, like, 부등호 같은 연산자로 조인해야 할 때도 있다. 아래는 부등호 조인을 통해 그림 2-23 우측과 같은 지점별 누적 매출을 구하는 방법을 예시하고 있다.

```sql
select t1.지점, t1.판매월, min(t1.매출) as 매출, Sum(t2.매출) as 누적매출
from 월별지점매출 t1, 월별지점매출 t2
where t2.지점 = t1.지점
and t2.판매월 <= t1.판매월
group by t1.지점, t1.판매월
order by t1.지점, t1.판매월;
```

### (2) 선분 이력 끊기

선분 이력 레코드를 가공해야 할 때가 있는데, 월말 기준으로 선분을 끊는 경우를 살펴보자. 본론으로 들어가기에 앞서, 두 선분이 겹치는 구간에 대한 시작일자 및 종료일자 선택 규칙에 대해 살펴보자.

시간을 나타내는 두 개의 선분이 서로 겹치는 모습을 표현하면 그림 2-24의 (a), (b), (c), (d)처럼 네 가지 패턴이 있다. (e), (f)는 참고로 그린 것이며, 서로 겹치지 않은 모습이다.

![](/assets/images/sqlp/sqlp2-02-08-2-img2-24.png)

점선 타원 표시는 두 선분이 겹치는 구간의 시작 및 종료 일자를 나타낸 것이다. 그리고 점선 화살 표는 시간의 진행 순서를 표시한 것이다.

(a), (b), (c), (d) 네 스타일의 특징과 겹치는 구간의 시작 및 종료 일자 선택 규칙을 정리하면, 아래 표와 같다. 설명의 편의를 위해, 그림 2-24에서 상단에 있는 선분의 시작일자와 종료일자를 각각 '시작일자1'과 '종료일자1'이라고 명명하였고, 하단에 있는 선분의 시작일자와 종료일자를 각각 '시작일자2'와 '종료일자2'라고 명명하였다.

![](/assets/images/sqlp/sqlp2-02-08-2-table1.png)

본론으로 들어가서, 그림 2-25처럼 월도와 선분이력 두 개의 테이블이 있을 때 선분 이력을 월도와 조인해서 맨 아래 쪽 변환된 선분 이력과 같은 형태로 만들려고 한다. 즉, 두 개 이상의 월도에 걸친 선분(5, 7)을 매 월말 기준으로 끊으려는 것이다.

![](/assets/images/sqlp/sqlp2-02-08-2-img2-25.png)

그리고 그림과 표를 자세히 분석하면 좀 더 간단한 규칙을 발견할 수 있는데, 겹치는 구간의 시작일자는 두 시작일자 중 큰 값을 취하면 되고 종료일자는 두 종료일자 중 작은 값을 취하면 된다.
따라서 최종적으로는 아래와 같이 쿼리하는 것이 가장 좋다.

```sql
select b.상품번호,
       greatest(a.시작일자, b.시작일자) as 시작일자,
       least(a.종료일자, b.종료일자) as 종료일자,
       b.데이터
from 월도 a, 선분이력 b
where b.시작일자 = a.종료일자
and b.종료일자 >= a.시작일자;
```

### (3) 데이터 복제를 통한 소계 구하기

쿼리를 작성하다보면 데이터 복제 기법을 활용해야 할 때가 많다. 방금 두 사례는 부등호 조인을 이용한 데이터 복제 방법이었는데, 일부러 카티션 곱(Cartesian Product)을 발생시켜 복제하기도 한다. 전통적으로 많이 쓰던 방식은 아래와 같은 복제용 테이블(copy)을 미리 만들어두고 이를 활용하는 것이다.

```sql
create table copy_t ( no number, no2 varchar2(2));

insert into copy_t
select rownum, lpad(rownum, 2, '0') from all_tables where rownum <= 31;

alter table copy_t add constraint copy_t_pk primary key (no);
create unique index copy_t_no_idx on copy_t (no2);
```

이제 아래 쿼리를 수행하면 emp 테이블에 있는 14개 레코드가 3개씩 총 42개로 복제된다.

```sql
select * from emp a, copy_t b
where b.no < 3;
```

오라클 9i부터는 dual 테이블을 사용하면 편하다. 아래와 같이 dual 테이블에 start with 절 없는 connect by 구문을 사용하면 두 개의 집합이 자동으로 만들어진다.

```sql
select rownum no from dual connect by level <= 2;

        NO
----------
         1
         2
```

이 방법을 사용해 emp 테이블을 복제하는 방법은 아래와 같다.

```sql
select * from emp a, (select rownum no from dual connect by level < 2) b;

......

28 개의 행이 선택되었습니다.
```

데이터 복제 기법을 활용하면 아래와 같이 단일 SQL로도 부서별 소계를 구할 수 있다.

![](/assets/images/sqlp/sqlp2-02-08-3-sql1.png)

이처럼 group by를 잘 구사하면 우리가 원하는 데이터 집합을 자유자재로 가공해낼 수 있다.
아래는 세 개로 복제하고서 총계까지 구하는 사례다.

![](/assets/images/sqlp/sqlp2-02-08-3-sql2.png)

물론 표준 rollup 구문을 사용하면 데이터 복제 기법을 쓰지 않고도 아래와 같이 간편하게 소계 및 총계를 구할 수 있다.

![](/assets/images/sqlp/sqlp2-02-08-3-sql3-1.png)
![](/assets/images/sqlp/sqlp2-02-08-3-sql3-2.png)
