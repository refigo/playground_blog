---
title: <오라클 성능 고도화 원리와 해법2> Ch01-07 인덱스 스캔효율
date: 2024-04-04
categories: [Database, SQL Tuning]
tags: [SQLP]
---

## 오라클 성능 고도화 원리와 해법2 - Ch01-07 인덱스 스캔효율

1권 6장 1절에서 블록 단위 I/O 원리를 설명하면서 Random 액세스와 Sequential 액세스의 차이점을 자세히 설명했다.

Sequential 액세스는 레코드간 논리적 또는 물리적인 순서를 따라 차례대로 읽어나가는 방식을 말하고, Random 액세스는 레코드간 논리적, 물리적인 순서를 따르지 않고 한 건을 읽기 위해 한 블록씩 접근하는 방식이라고했다. 그리고 I/O 튜닝의 핵심 원리로서 아래 두가지 항목을 꼽았다.

1. Sequential 액세스의 선택도를 높인다.
2. Random 액세스 발생량을 줄인다.

4절에서 테이블 Random 액세스 부하원리에 대해 설명했고, 5절과 6절에선 부하 해소 원리를 설명했는데, 이는 2번 항목에 해당한다.

지금부터는 1번 Sequential 액세스의 선택도를 높이는 방법에 대해 설명하려고 한다. 즉, 테이블을 액세스하기 전, 인덱스를 Sequential 방식으로 스캔하는 단계에서 발생하는 비효율 해소 원리를 다룬다.

| Sequential 액세스 선택도                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 일반적인 의미에서의 선택도는 전체 레코드 중에서 조건절에 의해 선택되는 비율을 말한다. 또한, 조나단 루이스는 그의 저서 "Cost-Based Oracle Fundamentals" 에서 인덱스 액세스에 대한 비용 공식을 쉽게 설명하려고 아래 두가지 용어를 도입하였으며, 4절에서 이미 소개한 바 있다.<br><br>- 유효 인덱스 선택도: 전체 인덱스 레코드 중에서 조건절을 만족하는 레코드를 찾기 위해 스캔할 것으로 예상되는 비율(%)<br>- 유효 테이블 선택도: 전체 레코드 중에서 인덱스 스캔을 완료하고서 최종적으로 테이블을 방문할 것으로 예상되는 비율(%)<br><br>조나단 루이스가 말하는 유효 테이블 선택도가 높다면 인덱스 스캔 후 테이블 Random 액세스 비율이 높은 것이므로 앞서 선택도가 높아야 효율적이라고 한 필자의 주장과 배치된다.<br><br>하지만 본절에서 말하는 Sequential 액세스 선택도는 인덱스를 스캔한 건수 중 결과로 선택되는 비율을 말하는 것이며, 그 비율이 높아야 효율적이라는 의미는 같은 결과 건수를 내기 위해 적은 양을 읽어야 함을 이르는 것이다. |

### (1) 비교 연산자 종류와 컬럼 순서에 따른 인덱스 레코드의 군집성

인덱스 스캔의 효율성을 설명하기에 앞서, 인덱스 레코드의 특성을 이해하는 게 필요하다.

테이블과는 다르게, 인덱스 레코드는 '같은 값을 갖는' 레코드들이 항상 서로 군집해 있다. 그러나 '같은 값'을 갖는 다'라고 하면 비교가 전제되므로, 만약 비교 연산자가 조건이 아닐 때는 인덱스 레코드도 서로 흩어진 상태일 수 있다. 그림 1-37을 보면서 이해해보자.

| 선두 컬럼, 선행 컬럼                                                                                                                                                                                                                                              |
| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 생각하기에 따라 같은 용어라고 해석될 수 있지만, 서로 헷갈리지 않도록 정리해보자. '선두 컬럼은 인덱스 구성상 맨 앞쪽에 있는 컬럼을 지칭할 때 사용하고, '선행 컬럼'은 상대적으로 앞쪽에 놓인 컬럼을 칭할 때 사용할 것이다. 선두 컬럼은 당연히 선행 컬럼에 포함된다. |

그림에서 리프 블록 아래 쪽에 있는 1부터 20까지의 숫자는 설명의 편의상 부여한 일련 번호다.

![](/assets/images/sqlp/sqlp2-01-07-1-img1-37.png)

여기서 우리는 한 가지 규칙을 발견할 수 있다. 선행 컬럼이 모두 '=' 조건인 상태에서 첫 번째 나타나는 범위 검색 조건까지만족하는 인덱스 레코드는 모두 연속되게 모여있지만, 그 이하 조건까지만족하는 레코드는 비교 연산자 종류에 상관없이 흩어진다(우연히 모여있을 수는 있음)는 규칙이다.

### (2) 인덱스 선행 컬럼이 등치(=) 조건이 아닐 때 발생하는 비효율

Sequential 액세스 효율은 선택도에 의해 결정된다. 다르게 표현하면, 같은 결과 건수를 내는데 얼마나 적은 레코드를 읽느냐로 효율성을 판단할 수 있다.

인덱스 Sequential 액세스에 따른 선택도는 인덱스 컬럼이 조건에 모두 등치(=) 조건으로 사용될 때가 가장 높다. 리프 블록을 스캔하면서 읽은 레코드는 하나도 필터링되지 않고 모두 테이블 액세스로 이어지기 때문이다. 따라서 인덱스 스캔 단계에서의 비효율은 전혀 없다.

인덱스 컬럼 중 일부가 조건절에서 생략되거나 조건이 아니더라도, 그것이 뒤쪽 컬럼일 때는 비효율이 없다.

반면에, 인덱스 선행 컬럼이 조건에 누락되거나 between, 부등호, like 같은 범위 검색 조건이 사용되면 인덱스를 스캔하는 단계에서 비효율이 발생한다.

인덱스 선행 컬럼이 모두 '조건일 때 필요한 범위만 스캔하고 멈출 수 있는 것은, 조건을 만족하는 레코드가 모두 한데 모여 있기 때문이다.

### (3) BETWEEN 조건을 IN-List로 바꾸었을 때 인덱스 스캔 효율

범위 점색 컬럼이 맨 뒤로 가도록 인덱스를 [아파트시세코드+평형+평형타입+인터넷매물] 순으로 변경하면 좋겠지만 운영 중인 시스템에서 인덱스 구성을 바꾸기는 쉽지 않다. 이럴 때 between 조건을 아래와 같이 IN-List로 바꿔주면 가끔 큰 효과를 얻는다.

IN-List 개수만큼 unional 브랜치가 생성되고, 각 브랜치마다 모든 컬럼을 조건으로 검색하기 때문에 앞서 선두 컬럼을 between 조건으로 비교할 때와 같은 비효율이 사라진다. 참고로, 3절에서 배운 IndexSkipScan 방식으로 유도하더라도 비슷한 효율을 얻을 수 있다.

#### between 조건을 IN-List 조건으로 바꿀 때 주의 사항

인덱스 선두 컬럼의 between 조건을 IN-List 조건으로 바꿀 때 주의할 점은, IN-List 개수가 많지 않아야 한다는 것이다. 그림1-39처럼 필요 없는 범위를 스캔하는 비효율은 사라지겠지만, 그림1-40처럼 인덱스 수직 탐색이 여러 번 발생하기 때문이다. IN-List 개수가 많을 때는, between 조건 때문에 리프 블록을 추가로 스캔하는 비효율 보다 IN-List 조건 때문에 브랜치 블록을 반복 탐색하는 비효율이 더 클 수 있고, 인덱스 높이(heigh)가 높을 때 특히 그렇다. (경우에 따라서는 인덱스 수직 탐색 과정에서의 일량도 상당하다. 그림1-2와 설명 참조)

인덱스 스캔 과정에서 선택되는 레코드들이 서로 멀리 떨어져 있을 때만 유용하다는 사실도 기억하기 바란다. between 조건인 선행 컬럼 때문에 많은 인덱스 리프 블록을 스캔하지만 거기서 선택되는 레코드는 소량일 때라야 IN-List로의 변환이 효과를 낸다. 왜냐면, 많은 레코드를 스캔하는 비효율이 있을지언정 블록 I/O 측면에서는 대개 소량에 그치는 경우가 많기 때문이다. 인덱스 리프 블록에는 테이블 블록과 달리 매우 많은(8KB 블록 기준으로 대략 수백개) 레코드가 담긴다.
