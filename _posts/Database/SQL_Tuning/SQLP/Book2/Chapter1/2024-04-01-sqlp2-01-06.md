---
title: <오라클 성능 고도화 원리와 해법2> Ch01-06 IOT, 클러스터 테이블 활용
date: 2024-04-01
categories: sql tuning
---

## 오라클 성능 고도화 원리와 해법2 - Ch01-06 IOT, 클러스터 테이블 활용

### (1) IOT란?

5절 (4)항에서 테이블 액세스 없이 인덱스만 읽고 처리하도록 튜닝하는 기법을 살펴보았다. Random 액세스가 발생하지 않도록 테이블을 아예 인덱스 구조로 생성하면 어떨까? 실제 오라클은 그런 식으로 테이블을 생성하는 방법을 제공하는 데, 이를 'IOT(Index-Organized Table)'이라고 부른다.

테이블을 찾아가기 위한 rowid를 갖는 일반 인덱스와 달리 IOT는 모든 행 데이터를 리프 블록에 저장하고 있다. 그림1-26에서 알 수 있는 것처럼 IOT에서는 "인덱스 리프 블록이 곧 데이터 블록"인 셈이다.

![](/assets/images/sqlp/sqlp2-01-06-1-img1-26.png)

테이블을 인덱스 구조로만드는 구문은 다음과 같다.

```sql
create table index_org_t ( a number primary key, b varchar(10) )
organization index ;
```

우리가 일반적으로 사용하는 테이블은 '구조 테이블'이라고 부르며, 테이블 생성시 대개 생
락하지만 아래와 같이 organization 옵션을 명시할 수도 있다.

```sql
create table heap org_t ( a number primary key, b varchar (10) )
organization heap ;
```

일반적인 힙 구조 테이블로의 데이터 삽입은 Random 방식으로 이루어진다. 즉, Freelist로부터 할당받은 블록에 정해진 순서 없이 값을 입력한다. 반면, IOT는 인덱스 구조 테이블이므로 정렬 상태를 유지하며 데이터를 삽입한다.

IOT는 SQL 서버나 Sybase에서 말하는 '클러스터형 인덱스(Clustered Index)와 비슷한 개념이라고 할 수 있다. 다만 오라클 IOT는 PK 컬럼 순으로만 정렬할 수 있다는 점이 다르다.`10)`

> 10. SQL 서버는 Unique하지 않은 일반 컬럼들을 정렬 기준으로 삼을 수 있는데, 그 때는 내부적으로 생성한 일련번호를 함께 저장함으로써 레코드를 유일하게 식별할 수 있게 한다. 그래야 클러스터형 인덱스를 가리키는 제2의 인덱스(비클러 스터형 인덱스)로부터 해당 레코드를 찾아갈 수 있기 때문이다.

#### IOT의 장점과 단점

IOT는 인위적으로 클러스터링 팩터를 좋게 만드는 방법 중 하나다. 같은 값을 가진 레코드들이 100% 정렬된 상태로 모여있기 때문에 Random 액세스가 아닌 Sequential 방식으로 데이터를 액세스할 수 있고, 이때문에 넓은 범위를 액세스할 때 유리하다.

PK 컬럼 기준으로 데이터가 모여있더라도 선행 컬럼이 '조건'이 아니면 조회 대상 레코드들이 서로 흩어져 많은 스캔을 유발하지만, 적어도 테이블 Random 액세스는 발생하지 않아 빠른 성능을 낼 수 있다. 테이블을 IOT로 생성하면 PK 인덱스를 위한 별도의 세그먼트를 생성하지 않아도 되어 저장공간을 절약하는 부수적인 이점도 생긴다.

IOT의 가장 큰 단점으로는 데이터 입력시 성능이 느리다는 점을 주로 꼽는다. 이 때문에 IOT를 피하는 설계자 또는 DBA를 자주 만나는데, 실제 테스트해보면 그럴 정도로 늦지는 않다. 일반 힙 구조 테이블에 PK 인덱스를 생성하지 않았을 때와 비교하면 당연히 많은 차이가 날 것이다.

그럼에도 둘 간에 성능 차이가 클 때는 인덱스 분할(Split) 발생량 차이 때문이다. IOT는 인덱스 구조이므로 중간에 꽉 찬 블록에 새로운 값 입력할 일이 종종 생기고 그럴 때 인덱스 분할(Split)이 발생한다. 그런데 IOT가 PK 이외에 많은 컬럼을 갖는다면 리프 블록에 저장해야 할 데이터량이 늘어나 그만큼 인덱스 분할 발생 빈도도 높아진다. 컬럼 수가 그렇게 많은 테이블이라면 인덱스 스캔 효율 때문에라도 IOT 대상으로는 부적합하다.

IOT에 Direct Path Insert가 작동하지 않는 것도 큰 제약 중 하나이며, 이 때문에 성능이 느린 것은 어쩔 수가 없다.

### (2) IOT, 언제 사용할 것인가?

IOT는 아래와 같은 상황에서 유용하다.

• 크기가 작고 NIL 조인으로 반복 룩업하는 테이블
• 폭이 좁고 긴(=로우 수가 많은) 테이블
• 넓은 범위를 주로 검색하는 테이블
• 데이터 입력과 조회 패턴이 서로 다른 테이블

#### 크기가 작고 NL 조인으로 반복 룩업하는 테이블

여기에는 주로 코드성 테이블이 속한다. NL 조인에서 Inner 쪽 룩업 테이블로서 액세스되는 동안 건건이 인덱스와 테이블 블록을 다 읽는다면 비효율적이다. 따라서 그런 테이블을 IOT로 구성해주면 적어도 테이블은 반복 액세스하지 않아도 된다.

다만, IOT 구성 시 PK 이외 속성의 크기 때문에 인덱스 높이가 증가한다면 역효과가 날 수 있으므로 이를 반드시 확인하기 바란다.

#### 폭이 좁고 긴(=로우 수가 많은) 테이블

두 테이블 간 M:M 관계를 해소하기 위한 Association(=Intersection) 테이블이 주로 여기에 속한다.

![](/assets/images/sqlp/sqlp2-01-06-1-img1-27.png)

그림 1-27에서 고객이나 컨텐츠 테이블은 (BRD에 표시하지 않았지만) PK 이외에도 많은 컬럼으로 구성된다. 하지만 컨텐츠 방문 테이블은 PK 11 (고객ID, 컨텐츠 ID, 방문 일시) 이외 컬럼이 전혀 없거나 있더라도 아주 소수에 불과하다 (= 폭이 좁다).

PK 인덱스는 어차피 생성해야 할 테고, 그러면 테이블과 거의 중복된 데이터를 갖게된다. 그럴 때 1:1로 구성해주면 중복을 피할 수 있다.

#### 넓은 범위를 주로 검색하는 테이블

주로 Between, Like 같은 조건으로 넓은 범위를 검색하는 테이블이라면, TOT 구성을 고려해 볼 만하다. 특히, PK 이외 컬럼이 별로 없는 통계성 테이블에는 최적의 솔루션이라고 할 수 있다.

통계성 테이블은 주로 넓은 범위 조건으로 검색하는 데 다, 일반적으로 그림 1-28 처럼 PK 구성 컬럼은 많으면서 일반(Non-Key) 속성은 몇 개 되지 않는다. PK 구성 컬럼이 많은 만큼 분석 관점(다차원 모델링에서 말하는 dimension)과 액세스 경로가 아주 다양한데, 이를 위해 B\*Tree 결합 인덱스를 계속 추가해나가는 것은 저장 공간이나 DML 부하 측면에서 문제가 많다.

![](/assets/images/sqlp/sqlp2-01-06-1-img1-28.png)

그럴 때 테이블을 IOT로 구성하면 효과적이다. 우선 PK 인덱스를 위한 별도 공간이 필요하지 않다는 점이 맘에든다. 정렬 순서를 잘 정의하면 인덱스를 여러 개 두지 않고도 다양한 검색 조건에 대응할 수 있고, 무엇보다 테이블 Random 액세스가 전혀 발생하지 않는다는 점에서 강력하다.

정렬 순서는 어떻게, 정하는 것이 좋을까? 7절과 8절에서 자세히 설명하겠지만 통계성 테이블 검색 시 항상 사용되는 일자 컬럼은 대부분 between 조건이므로 선두 컬럼으로 부적합하다. 조건으로 항상 사용되는 컬럼 한 두 개(그림 1-28 사례에서는 'AS 유형 코드')를 찾아 선두에 두고 바로 이어서 일자 컬럼이 오도록 1:1을 구성하는 것이 효과적이다. 범위 검색 조건인 일자 뒤쪽에 놓인 컬럼이 조건으로 입력되더라도 스캔 범위를 줄이는 데에 큰 역할을 못해 생기는 비효율이 있긴 하지만 Random 액세스가 발생하지 않는 것만으로도 대부분 만족스러운 성능을 낼 수 있다.

데이터가 너무 많아지면 인덱스 높이( height )가 증가하고 관리 부담이 커질 수 있는데, 뒤에서 설명할 Partitioned IOT를 활용할 수 있으므로 걱정하지 않아도 된다.

참고로, 그림 1-28과 같은 팩트(ac)성 테이블에 대한 인덱스 구성 전략을 얘기할 때면 흔히 비트맵 인덱스가 거론되곤 한다. 하지만 여러 비트맵 인덱스로 Bit-Wise 오퍼레이션을 수행한 결과 테이블 액세스량이 획기적으로 줄어드는 경우가 아니라면 즉, Random 액세스 발생량이 많다면 비트맵 인덱스는 성능 개선에 그다지 도움이 되지 못한다.

| 비트맵 인덱스에 대한 오해                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 성별처럼 Distinct Value 개수가 적은 컬럼으로 조회할 때 비트맵 인덱스를 사용하면 빠르다고<br><br> 생각하는 분들이 많다. 즉, 넓은 범위를 조회할 때 B*Tree 인덱스보다 성능을 크게 향상시켜준다는 얘긴데, 과연 그럴까?<br><br>그런 컬럼이라야 비트맵 인덱스의 저장 효율이 좋은 것은 사실이지만 조회 성능이 그다지 좋지는 않다. 테이블 Random 액세스 발생 측면에서는 B*Tree 인덱스와 똑같기 때문이며, 스캔할 인덱스 블록이 줄어드는 정도의 이점만 생긴다.<br><br>요컨대, 하나의 비트맵 인덱스 단독으로는 쓰임새가 별로 없다. 비트맵 인덱스가 가진 여러 가지 특징(특히, 용량이 작고 여러 인덱스를 동시에 사용할 수 있다는 특징 때문에 읽기 위주의 대용량 DW 환경에 적합한 것일 뿐 대용량 데이터 조회에 유리한 것은 아님을 기억하기 바란다. 자세한 설명은 9절을 참조하기 바란다. |

#### 데이터 입력과 조회 패턴이 서로 다른 테이블

회사에 100명의 영업 사원이 있다고 하자. 영업 사원들의 일별 실적을 집계하는 테이블이 있는 데, 한 블록에 100개 레코드가 담긴다. 그러면 매일 한 블록씩 1년이면 365개 블록이 생긴다.

이처럼 실적 등록은 일자별로 진행되지만 실적 조회는 주로 사원별로 이루어진다. 예를 들어, 일상적으로 아래 쿼리가 가장 많이 수행된다고 하자.

```sql
SELECT SUBSTR(일자, 1, 6) AS 월도
     , SUM(판매금액) 총판매금액, AVG(판매금액) 평균판매금액
FROM  영업실적
WHERE 사번 = 'S1234'
AND   일자 BETWEEN '20090101' AND '20091231'
GROUP BY SUBSTR(일자, 1, 6)
```

그러면 인덱스를 경유해 사원마다 365개 테이블 블록을 읽어야 한다. 클러스터링 팩터가 매우 안 좋기 때문이며, 입력과 조회 패턴이 서로 다르서 생기는 현상이다. 그럴 때 아래와 같이 사번이 첫번째 정렬 기준이 되도록 IOT를 구성해주면, 한 블록만 읽고 처리할 수 있다.

```sql
CREATE TABLE 영업실적 ( 사번 VARCHAR2(5), 일자 VARCHAR2(8), ...
    , CONSTRAINT 영업실적_PK PRIMARY KEY (사번, 일자) ) ORGANIZATION INDEX;
```

### (3) Partitioned IOT

수억 전에 이르는 일별 상품별 계좌별 거래 테이블이 있다고 하자. 그리고 아래 쿼리 1처럼 넓은 범위의 거래 일자를 기준으로 특정 상품을 조회하는 쿼리가 가장 자주 수행된다.

#### [ 쿼리 1 ]

```sql
SELECT 거래일자, 지점번호, 계좌번호, SUM(거래량), SUM(거래금액)
FROM   일별상품별계좌별거래
WHERE  상품번호 = 'P7006050009'
AND    거래일자 BETWEEN '20080101' AND '20080630'
GROUP BY 거래일자, 지점번호, 계좌번호
```

상품별 거래 건수가 워낙 많아 쿼리 1에 인덱스를 사용하면 Random 액세스 부하가 심하게 발생한다. 거래 일자 기준으로 월별 Range 파티셔닝되어 있다면 인덱스를 이용하기보다 필요한 파티션만 Full Scan 하는 편이 어려 빠를 것이다만 다른 종목의 거래 데이터까지 모두 읽는 비효율이 생긴다.

[상품번호+거래일자] 순으로 정렬되도록 IOT를 구성하면 읽기 성능이야 획기적으로 개선되겠지만, 수억 건에 이르는 테이블을 단일 IOT로 구성하는 것은 관리상 여간 부담스럽지 않다. 더구나, 아래 쿼리 2 때문에라도 그럴 수가 없다. 단일 IOT를 구성하면 쿼리 2는 수억 건에 이르는 데이터를 Full Scan 해야만 한다.

#### [ 쿼리 2 ]

```sql
SELECT 상품번호, 거래일자, SUM(거래량), SUM(거래금액)
FROM   일별상품별계좌별거래
WHERE  거래일자 BETWEEN '20080101' AND '20080630'
GROUP BY 상품번호, 거래일자
```

이럴 때 그림 1-29 처럼 Partitioned IOT를 구성하면 두 마리 토끼를 다 잡을 수 있다.

![](/assets/images/sqlp/sqlp2-01-06-3-img1-29.png)

• 거래 일자 기준 Range 파티셔닝
• [상품번호+거래일자] 순으로 PK를 정의하고, IOT 구성

쿼리 1을 위해서는 입력한 거래 일자 구간에 속하는 파티션 IOT를 골라 필요한 종목 거래 데이터만 스캔하면 되고, 쿼리 2를 위해서는 검색 구간에 속하는 파티션 세그먼트 전체를 Full Scan 하면 된다.

### (4) Overflow 영역

앞에서 여러 차례 언급했듯이 PK 이외 컬럼이 많은 테이블일수록 IOT로 구성하기에 부적합하다. 인덱스 분할에 의한 DML 부하는 물론, 검색을 위한 스캔량도 늘어나기 때문이다.

그럼에도 성능 향상을 위해 IOT가 꼭 필요하다면 어떻게 해야 할까? 그럴 때 Overflow 기능이 도움이 될 수 있는데, 아래 사례를 보면서 설명해보자.

![](/assets/images/sqlp/sqlp2-01-06-4-example1.png)

위 불공정거래적출 테이블에서 생성자ID, 수정자ID, 생성일시, 수정일시는 시스템 내부적인 필요에 의해 생겨난 관리 속성이지 업무 요건에 의한 것은 아니다. 따라서 값은 저장해두지만 출력이나 조회 조건으로는 거의 사용되지 않는다.

만약 이런 컬럼들을 다른 주요 컬럼과 분리해서 저장할 수 있다면 IOT 활용성을 높일 수 있는데, 다행히 오라클이 그런 기능을 제공한다. 아래 스크립트 하단에 지정한 옵션들이 그것이며, 각각 아래와 같은 의미를 갖는다.

- OVERFLOW TABLESPACE: Overflow 세그먼트가 저장될 테이블 스페이스를 지정한다. ※ SYSIOT_OVER38645 등의 이름을 가진 세그먼트가 자동으로 생성된다.
- PCT THRESHOLD: DEFAULT 값은 50이다. 예를 들어 이 값이 30이면, 블록 크기의 30%를 초과하기 직전 컬럼까지만 인덱스 블록에 저장하고 그 뒤쪽 컬럼은 모두 Overflow 세그먼트에 저장한다. 물론 로우 전체 크기가 지정된 비율 크기보다 작다면 모두 인덱스 블록에 저장한다. 테이블을 생성하는 시점에 모든 컬럼의 데이터 타입 Max 길이를 합산한 크기가 이 비율 크기보다 작다면 Overflow 세그먼트는 불필요하지만 만약 초과한다면 오라클은 Overflow Tablespace 옵션을 반드시 지정하도록 강제하는 에러를 던진다.
- INCLUDING: Including에 지정한 컬럼까지만 인덱스 블록에 저장하고 나머지는 무조건 Overflow 세그먼트에 저장한다.

오라클은 Pctthreshold 또는 Including 둘 중 하나를 만족하는 컬럼을 Overflow 영역에 저장한다. 즉, Including 이전에 위치한 컬럼이더라도 Pctthreshold에 지정된 비율 크기를 초과한다면 Overflow 영역에 저장된다. 반대의 경우도 마찬가지다.

반드시 기억할 것은, Overflow 영역을 읽을 때도 건건이 Random 액세스가 발생한다는 사실이다. 따라서 Overflow 세그먼트에 저장된 컬럼 중 일부를 자주 액세스해야 하는 상황이 발생한다면 IOT 액세스 효율은 급격히 저하된다. Pct threshold를 신중히 선택해야 함은 물론 Including 절에 어떤 컬럼을 지정하느냐가 관건이라고 하겠다.

![](/assets/images/sqlp/sqlp2-01-06-4-img1-30.png)

다행스러운 것은, Overflow 영역에도 버퍼 Pinning 효과가 나타나기 때문에 연속적으로 같은 Overflow 블록을 읽을 때는 Random 블록 I/O를 최소화 할 수 있다.
