---
title: <오라클 성능 고도화 원리와 해법2> Ch06-03 인덱스 파티셔닝
date: 2024-05-24
categories: [Database, SQL Tuning]
tags: [SQLP]
---

## 오라클 성능 고도화 원리와 해법2 - Ch06-03 인덱스 파티셔닝

### (1) 인덱스 파티션 유형

테이블 파티셔닝에 대해 살펴봤고, 이제는 인덱스 파티셔닝에 대해 설명하려고 한다. 인덱스 파티셔닝은 테이블 파티셔닝과 맞물려 다양한 구성이 존재한다. 따라서 테이블을 다음과 같이 구분하고서 인덱스 파티션 유형에 대한 설명을 시작해야 한다.

- 비파티션 테이블 (Non-Partitioned Table)
- 파티션 테이블 (Partitioned Table)

인덱스도 테이블처럼 파티션 여부에 따라 비파티션 인덱스와 파티션 인덱스로 나뉘며, 파티션 인덱스는 각 인덱스 파티션이 담당하는 테이블 파티션 범위에 따라 글로벌과 로컬로 나뉜다.

- 비파티션 인덱스 (Non-Partitioned Index)
- 글로벌 파티션 인덱스 (Global Partitioned Index)
- 로컬 파티션 인덱스 (Local Partitioned Index)

뒤에서 다시 설명하겠지만 로컬 파티션 인덱스는 각 테이블 파티션과 인덱스 파티션이 서로 1:1 대응 관계가 되도록 오라클이 자동으로 관리하는 파티션 인덱스를 말한다. 로컬이 아닌 파티션 인덱스는 모두 글로벌 파티션 인덱스에 속하며, 테이블 파티션과 독립적인 구성(파티션 키, 파티션 기준 값)을 갖는다.

참고로, 인덱스를 글로벌과 로컬로 먼저 나누고, 글로벌을 다시 파티션과 비파티션으로 나누는 분류 방식도 있다. 이때는 비파티션 인덱스를 '글로벌 비파티션 인덱스 (Global Non-Partitioned Index)'라고 부른다.

이 책에서는 처음 설명한 분류 방식을 사용하지만, 편의상 '글로벌 인덱스 (Global Index)'라고 줄여 부를 때는 비파티션 인덱스와 글로벌 파티션 인덱스를 같이 일컫는 말임을 미리 밝힌다.

- 글로벌 인덱스 = 비파티션 인덱스 + 글로벌 파티션 인덱스

이제 테이블과 인덱스 파티셔닝 구분을 서로 조합해보면 아래와 같은 구성이 생긴다.

![](/assets/images/sqlp/sqlp2-06-03-1-table1.png)

- 비파티션 테이블은 비파티션 인덱스와 글로벌 파티션 인덱스를 가질 수 있다.
- 파티션 테이블은 비파티션 인덱스, 글로벌 파티션 인덱스, 로컬 파티션 인덱스를 가질 수 있다.

참고로, 비파티션 테이블에 대한 비트맵 인덱스는 파티셔닝이 허용되지 않으며, 파티션 테이블에 대한 비트맵 인덱스는 로컬 파티셔닝만 허용된다.

### (2) 로컬 파티션 인덱스

이 장을 시작하면서 테이블 파티션을 계절별로 옷을 관리하는 서랍장에 비유했는데, 로컬 파티션 인덱스(Local Partitioned Index)는 계절별로 별도 색인을 다는 것과 같다. 따라서 각 인덱스 파티션이 테이블 파티션과 1:1 대응 관계를 가지며, 테이블 파티션 속성을 그대로 상속받는다. 파티셔닝을 전제로 하므로 흔히 '로컬 인덱스'라고 줄여서 부른다.

![](/assets/images/sqlp/sqlp2-06-03-2-img6-8.png)

파티션 키를 사용자가 따로 정의하지 않아도 오라클이 자동으로 관리한다는 것이 특징이다. 테이블 파티션과 1:1 관계가 되도록 사용자가 수동으로 인덱스 파티션을 구성하더라도 이를 로컬 파티션 인덱스라고 부르지 않는 이유가 여기에 있다.

로컬 파티션 인덱스는 항상 테이블 파티션과 1:1 관계를 형성하므로 만약 테이블이 결합 파티셔닝(Composite Partitioning)되어 있다면 인덱스도 같은 단위로 파티셔닝된다.

로컬 파티션 인덱스가 갖는 장점은 무엇보다 관리적 편의성에 있다. 테이블 파티션 구성에 변경(drop, exchange, split 등)이 생기더라도 인덱스를 재생성할 필요가 없어 관리 비용이 아주 적다.

### (3) 비파티션 인덱스

비파티션 인덱스(Non-Partitioned Index)는 말 그대로 파티셔닝하지 않은 인덱스를 말한다. 테이블이 파티셔닝돼있다면 그림 6-9에서 보듯이 1:M 관계에 놓인다. 즉, 하나의 인덱스 세그먼트가 여러 테이블 파티션 세그먼트와 관계를 갖는다. 그런 의미에서 비파티션 인덱스를 '글로벌 비파티션 인덱스'라고 부르기도 한다.

![](/assets/images/sqlp/sqlp2-06-03-3-img6-9.png)

### (4) 글로벌 파티션 인덱스

글로벌 파티션 인덱스(Global Partitioned Index)는 그림 6-10에서 보는 것처럼 테이블 파티션과 독립적인 구성을 갖도록 파티셔닝하는 것을 말한다. 테이블은 파티셔닝돼있지 않을 수도 있다.

![](/assets/images/sqlp/sqlp2-06-03-3-img6-10.png)

독립적 구성이라는 점에서 효용성이 높을 것처럼 보이지만, 몇몇 제약 사항 때문에 오히려 효용성이 낮은 편이다. 글로벌 파티션 인덱스 사용을 불편하게 만드는 가장 큰 제약은 기준 테이블의 파티션 구성에 변경(drop, exchange, split 등)이 생길 때마다 인덱스가 unusable 상태로 바뀌고 그때마다 인덱스를 재생성해야 한다는 것이다. 이 제약은 비파티션 인덱스일 때도 똑같이 나타난다.

9i부터는 아래와 같이 `update global indexes` 옵션을 주면 파티션 DDL 작업에 의해 영향을 받는 인덱스 레코드를 자동으로 갱신해주므로 인덱스가 unusable 상태로 빠지지 않는다.

```sql
ALTER TABLE ...
SPLIT PARTITION ...
UPDATE GLOBAL INDEXES;
```

하지만, 파티션 DDL로 인해 영향을 받는 레코드가 전체의 5% 미만일 때만 유용하다. 다시 말해, 5% 이상일 때는 인덱스를 재생성하는 것보다 오히려 늦다는 뜻이다. (항상 들어맞는 수치는 아니며, 평균적으로 그렇다는 것이다. 인덱스 손익분기점과 같은 개념으로 이해하면 된다.)

#### 테이블 파티션과의 관계

"오라클이 자동으로 관리해주는 1:1 관계"가 아닌 파티션 인덱스는 모두 글로벌 파티션 인덱스라고 설명했다.

인덱스를 테이블 파티션과 같은 키 컬럼으로 글로벌 파티셔닝한다면 파티션 기준값을 어떻게 정의하느냐에 따라 1:M, M:1, M:M 관계가 모두 가능하다. 그렇더라도 본질적인 관계는 M:M으로 이해해야 한다. 즉, 하나의 인덱스 파티션이 여러 테이블 파티션과 관계를 갖고, 반대로 하나의 테이블 파티션이 여러 인덱스 파티션과 관계를 갖는다. M:M은 다른 모든 관계를 포함한다는 사실을 상기하기 바란다.

참고로, 로컬 파티션 인덱스(그림 6-8)처럼 테이블과 1:1 관계가 되도록 수동으로 구성하더라도 여느 글로벌 파티션과 마찬가지로 기준 테이블 구성에 변경이 발생할 때마다 인덱스를 재생성해야 한다.

인덱스를 테이블 파티션과 다른 키 컬럼으로 글로벌 파티셔닝할 수도 있는데, 예를 들어 테이블은 주문일자, 인덱스는 배송일자에 따라 파티셔닝할 수 있다. 이때는 테이블 파티션과 인덱스 파티션 간에는 항상 M:M 관계가 형성된다.

#### 글로벌 해시 파티션 인덱스

글로벌 파티션 인덱스의 경우, 9i까지는 글로벌 Range 파티션만 가능했지만 10g부터는 글로벌 해시 파티션도 가능해졌다. 즉, 테이블과 독립적으로 인덱스만 해시 키 값에 따라 파티셔닝할 수 있게 되었다. 글로벌 해시 파티션 인덱스는 Right Growing 인덱스처럼 Hot 블록이 발생하는 인덱스의 경합을 분산할 목적으로 주로 사용된다. 글로벌 결합(Composite) 인덱스 파티셔닝은 여전히 불가능하다.

