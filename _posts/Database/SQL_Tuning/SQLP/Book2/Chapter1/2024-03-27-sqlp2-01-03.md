---
title: <오라클 성능 고도화 원리와 해법2> Ch01-03 다양한 인덱스 스캔 방식
date: 2024-03-27
categories: sql tuning
---


## 오라클 성능 고도화 원리와 해법2 - Ch01-03 다양한 인덱스 스캔 방식

### (1) Index Range Scan

Index Range Scan은 그림1-4처럼 인덱스 루트 블록에서 리프 블록까지 수직적으로 탐색한 후에 리프 블록을 필요한 범위만 스캔하는 방식이다. B\*Tree 인덱스의 가장 일반적이고 정상적인 형태의 액세스 방식이라고 할 수 있고, 실행 계획에는 아래와 같이 표시된다.

sqlp2-01-03-1-EP1-1

sqlp2-01-03-1-EP1-2


sqlp2-01-03-1-img1-4


인덱스를 수직적으로 탐색한 후에 리프 블록에서 "필요한 범위만" 스캔한다고 했는데, 이는 범위 스캔(Range Scan)이 의미하는바를 잘 설명해주고 있다. 데이터베이스 프로그래밍에 경험이 많지 않은 초급 개발자는 대개 인덱스가 사용되는 실행 계획을 보면 자신이 작성한 SQL 문에 문제가 없다고 판단하고 일단 안심한다. **하지만 실행 계획상에 Index Range Scan이나타난다고 해서 항상 빠른 속도를 보장하는 것은 아니다.**

**인덱스를 스캔하는 범위(Range)를 얼마만큼 줄일 수 있느냐, 그리고 테이블로 액세스하는 횟수를 얼마만큼 줄일 수 있느냐가 관건이며, 이는 인덱스 설계와 SQL 튜닝의 핵심 원리중 하나이다.**

**Index Range Scan이 가능하게 하려면 인덱스를 구성하는 선두 컬럼이 조건에 사용되어야 한다.** 그렇지 못한 상황에서 인덱스를 사용하도록 힌트로 강제한다면 바로 이어서 설명할 Index Full Scan 방식으로 처리된다.

**Index Range Scan 과정을 거쳐 생성된 결과집합은 인덱스 컬럼 순으로 정렬된 상태가 되기 때문에 이런 특징을 잘 이용하면 sort order by 연산을 생략하거나 min/max값을 빠르게 추출할 수 있다.**

### (2) Index Full Scan

Index Full Scan은 수직적 탐색 없이 인덱스 리프 블록을 처음부터 끝까지 수평적으로 탐색하는 방식으로서, 대개는 데이터 검색을 위한 최적의 인덱스가 없을 때 차선으로 선택된다. 아래는 Index Full Scan할 때의 실행 계획이다.

sqlp2-01-03-2-EP1-1

sqlp2-01-03-2-EP1-2


sqlp2-01-03-2-img1-5


수직적 탐색 없이 인덱스 리프 블록을 처음부터 끝까지 수평적으로만 탐색한다고 했는데, 이는 개념적으로 설명하기 위한 것일 뿐 **실제로는 그림1-5처럼 수직적 탐색이 먼저 일어난다. 루트 블록과 브랜치 블록을 거치지 않고는 가장 왼쪽에 위치한 첫번째 리프 블록으로 찾아갈 방법이 없기 때문이다.** 그래서 이 과정을 그림1-5에 점선으로 표시한 것이다.

#### Index Full Scan의 효용성

위 SQL처럼 인덱스 선두 컬럼(ename)이 조건절에 없으면 옵티마이저는 우선적으로 Table Full Scan을 고려한다. 그런데 대용량 테이블이어서 Table Full Scan의 부담이 크다면 옵티마이저는 인덱스를 활용하는 방법을 다시 생각해보지 않을 수 없다.

**데이터 저장공간은 '가로 X 세로' 즉, '컬럼길이 X 레코드수'에 의해 결정되므로 대개 인덱스가 차지하는 면적은 테이블보다 훨씬 적게 마련이다. 만약 테이블 전체를 스캔하기보다 인덱스 스캔 단계에서 대부분의 레코드를 필터링하고 일부에 대해서만 테이블 액세스가 발생하도록 할 수 있다면 전체적인 I/O 효율 측면에서 이 방식이 유리하다. 이럴 때 옵티마이저는 Index Full Scan 방식을 선택할 수 있다.**

아래는 Index Full Scan이 효과를 발휘하는 전형적인 케이스다.

sqlp2-01-03-2-EP2-1

sqlp2-01-03-2-EP2-2


sqlp2-01-03-2-img1-6


그림1-6처럼 연봉이 5,000을 초과하는 사원이 전체 중 극히 일부라면 Table Full Scan보다는 Index Full Scan을 통한 필터링이 큰 효과를 가져다준다. 하지만 이런 방식은 적절한 인덱스가 없어 Index Range Scan의 차선책으로 선택된 것이므로, 할 수 있다면 인덱스 구성을 조정해 주는 것이 좋다.

#### 인덱스를 이용한 소트 연산 대체

Index Full Scan은 Index Range Scan과 마찬가지로 결과집합이 인덱스 컬럼 순으로 정렬되므로 Sort Order By 연산을 생략할 목적으로 사용될 수도 있는데, 이는 차선책으로 선택됐다기보다 옵티마이저가 전략적으로 선택한 경우에 해당한다.

sqlp2-01-03-2-EP3


sqlp2-01-03-2-img1-7



그림1-7에서 대부분 사원의 연봉이 1,000을 초과하므로 Index Full Scan을 하면 거의 모든 레코드에 대해 테이블 액세스가 발생해 Table Full Scan보다 오히려 불리하다. 만약 SAL이 인덱스 선두 컬럼이어서 Index Range Scan하더라도 마찬가지다. 그럼에도 여기서 인덱스가 사용된 것은 사용자가 first_rows 힌트를 이용해 옵티마이저 모드를 바꿨기 때문이다. 즉, 옵티마이저는 소트 연산을 생략함으로써 전체 집합 중 처음 일부만을 빠르게 리턴할 목적으로 Index Full Scan 방식을 선택한 것이다.

사용자가 그러나 처음 의도와 다르게 데이터를 읽기를 멈추지 않고 끝까지 fetch 한다면 Full Table Scan한 것보다 훨씬 더 많은 I/O를 일으키면서 서버 자원을 낭비하는 결과를 초래할 텐데, 이는 옵티마이저의 잘못이 결코 아니며 first_rows 힌트를 사용한 사용자에게 책임이 있다.

### (3) Index Unique Scan

Index Unique Scan은 그림1-8처럼 수직적 탐색만으로 데이터를 찾는 스캔 방식으로서, Unique 인덱스를 통해 '=' 조건으로 탐색하는 경우에 작동한다.

sqlp2-01-03-3-EP1-1

sqlp2-01-03-3-EP1-2


sqlp2-01-03-3-img1-8



**Unique 인덱스가 존재하는 컬럼은 중복값이 발생하지 않도록 DBMS가 데이터 정합성을 관리해준다. 따라서 해당 인덱스 키 컬럼을 모두 '=' 조건으로 검색할 때는 데이터를 한 건 찾는 순간 더 이상 탐색할 필요가 없다.**

Unique 인덱스라도 범위 검색 조건(between, 부등호, like)으로 검색할 때는 Index Range Scan으로 처리된다. 예를 들어, empno >= 7788 조건으로 검색하는 경우 수직적 탐색만으로는 조건에 해당하는 레코드를 모두 찾을 수 없기 때문이다.

또한, Unique 결합 인덱스에 대해 일부 컬럼만으로 검색할 때도 Index Range Scan이 나타난다. 예를 들어, 주문 상품 PK 인덱스가 [주문일자 + 고객ID + 상품ID]로 구성됐는데, 주문일자와 고객ID로만 검색하는 경우를 말한다.

