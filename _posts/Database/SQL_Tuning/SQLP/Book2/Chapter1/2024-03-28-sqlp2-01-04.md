---
title: <오라클 성능 고도화 원리와 해법2> Ch01-04 테이블 Random 액세스 부하
date: 2024-03-28
categories: sql tuning
---


## 오라클 성능 고도화 원리와 해법2 - Ch01-04 테이블 Random 액세스 부하

SQL 튜닝, 그 중에서도 인덱스 원리를 공부하면서 누구나 두 번 놀라게 된다. 첫째로는 인덱스를 효과적으로 활용했을 때 쿼리 성능이 얼마나 빨라지는지를 느꼈을 때이고, 둘째로는 대량의 데이터를 인덱스를 통해 액세스할 때 쿼리 성능이 얼마나 느려지는지를 느꼈을 때다.

본 절에서는 대량의 데이터를 처리할 때 테이블 랜덤 액세스가 가장 큰 부하 요인으로 작용하는 원인을 자세히 설명하고, 5절과 6절에서 이를 해소하기 위한 튜닝 방안을 소개한다.

### (1) 인덱스 ROWID에 의한 테이블 액세스

앞 절에서 다양한 인덱스 스캔 방식에 대해 살펴봤는데, 쿼리에서 참조되는 컬럼이 인덱스에 모두 포함되는 경우가 아니라면 인덱스 스캔 이후 테이블 랜덤 액세스가 일어난다. 아래 실행 계획에서 'Table Access By Index ROWID'라고 표시된 부분을 말하며, 지금부터 그 내부 메커니즘을 자세히 살펴보자.

sqlp2-01-04-1-sql1


#### 물리적 주소? 논리적 주소?

인덱스에 저장된 ROWID는 흔히 '물리적 주소 정보'라고 일컬어지는데, 오브젝트 번호, 데이터 파일 번호, 블록 번호 같은 물리적 요소들로 구성되어 있기 때문일 것이다. 하지만 보는 시각에 따라서는 '논리적 주소 정보'라고 표현하기도 한다. **ROWID가 물리적 위치 정보로 구성되지만 인덱스에서 테이블 레코드로 직접 연결되는 구조는 아니기 때문이다.**

#### 메인 메모리 DB와의 비교

메인 메모리 DB(MMDB)에 대해 들어본 적이 있을까? 말 그대로 데이터를 모두 메모리에 로드해놓고 메모리를 통해서만 I/O를 수행하는 DB라고 할 수 있다. 그런데 잘 튜닝된 OLTP 성 오라클 데이터베이스라면 버퍼 캐시 히트율이 99% 이상이므로 대부분 디스크를 경유하지 않고 메모리 상에서 I/O를 수행할 텐데도 메인 메모리 DB만큼 빠르지는 않다. 특히 대량의 테이블을 인덱스를 통해 액세스할 때는 엄청난 차이가 난다. 왜 그럴까?

메인 메모리 DB도 벤더에 따라 내부적으로 다른 아키텍처를 사용하겠지만 필자가 아는 어떤 제품의 아키텍처를 소개함으로써 방금 던진 질문에 대한 답을 찾고자 한다.

**메인 메모리 DB에서 인스턴스를 기동하면 디스크에 저장된 데이터를 버퍼 캐시로 로딩하고 이어서 인덱스를 실시간으로 만든다. 이때 인덱스는 오라클처럼 디스크 상의 주소 정보를 담는 게 아니라 메모리 상의 주소 정보, 즉 포인터를 담는다. 프로그래머라면 누구나 포인터 개념을 공부하므로 포인터에 의한 액세스가 얼마나 빠른지는 잘 알 것이다.**

**메모리 상에서 데이터를 찾아가는데 있어 포인터만큼 빠른 방법은 없으며 그 비용은 거의 0에 가깝다. 따라서 인덱스를 경유해 테이블을 액세스하는데 대한 비용이 오라클과 비교할 수 없을 정도로 낮다.**

질문에 대한 답이 무엇인지, 이해했으리라 믿는다. 오라클은 테이블 블록이 수시로 버퍼 캐시에 서 밀려났다가 다시 캐싱되며, 그때마다 다른 공간에 캐싱되기 때문에 인덱스에서 직접 포인터로 연결할 수 없는 구조다. 대신 디스크 상의 블록 위치 정보, 즉 DBA(Data Block Address)를 해시키 값으로 삼아 해싱 알고리즘을 통해 버퍼 블록을 찾는다. 매번 위치가 달라지더라도 캐싱되는 해시 버킷만큼은 고정적이다.

여기서 메인 메모리 DB의 우월성을 강조하고자 하는 것은 아니며(메인 메모리 DB는 데이터 볼륨이 그리 크지 않으면서, 기존 디스크 DB로는 도저히 만족할 수 없을 정도의 빠른 트랜잭션 처리가 요구되는 업무에서만 제한적으로 사용되고 있음), **우리가 사용하는 오라클 데이터베이스에서 인덱스 rowid에 의한 테이블 액세스가 생각만큼 빠르지 않은 이유를 설명하려는 것이다.**

#### rowid는 우편 주소에 해당

비유하자면, 오라클에서의 rowid는 우편 주소에 해당하고, 메인 메모리 DB에서 사용하는 포인터는 전화번호에 해당한다. 전화는 물리적으로 연결된 구조여서 전화번호만 누르면 곧바로 상대방과 직접 통화할 수 있지만, 우편 주소는 봉투에 적힌 대로 우체부 아저씨가 일일이 찾아다니는 구조이므로 전화와는 비교할 수 없이 느리다.

sqlp2-01-04-1-example1


#### 인덱스 rowid에 의한 테이블 액세스 구조

1권 1장 3절에서 설명한 것처럼(잠시 후 다시 자세히 설명함) 오라클도 포인터로 빠르게 액세스하는 버퍼 Pinning 기법을 사용하지만 반복적으로 읽힐 가능성이 큰 블록에 대해서만 일부 적용하고 있다. 이 메커니즘의 도움을 받지 않은 일반적인 인덱스 rowid에 의한 테이블 액세스가 실제로 얼마나 고비용인지, 1권 1장에서 보았던 그림 1-148)을 보면서 상기해보자.

sqlp2-01-04-1-img1-14


**오라클에서 하나의 레코드를 찾아가는데 있어 가장 빠르다고 알려진 rowid에 의한 테이블 액세스가 경우에 따라서는(-> 위 설명은 가장 최악의 상황을 가정한 것임) 이렇게까지 고비용이라는 사실을 상기시키기 위함이다.**

**요약하면, 인덱스 rowid는 테이블 레코드와 물리적으로 연결돼 있지 않기 때문에 인덱스를 통한 테이블 액세스는 생각보다 고비용 구조다. 설령 모든 데이터가 메모리에 캐싱돼 있더라도 테이블 레코드를 찾기 위해 매번 DBA를 해싱하고 래치 획득 과정을 반복해야 하기 때문이며, 동시 액세스가 심할 때는 래치와 버퍼 Lock에 대한 경합까지 발생한다.**

앞으로 실행 계획에서 아래와 같이 'Table Access By Index ROWID' 오퍼레이션을 볼 때면 위에서 설명한 복잡한 처리 과정을 항상 머리속에 떠올리기 바란다.

