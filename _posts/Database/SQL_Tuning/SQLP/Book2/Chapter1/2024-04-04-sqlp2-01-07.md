---
title: <오라클 성능 고도화 원리와 해법2> Ch01-07 인덱스 스캔효율
date: 2024-04-04
categories: [Database, SQL Tuning]
tags: [SQLP]
---

## 오라클 성능 고도화 원리와 해법2 - Ch01-07 인덱스 스캔효율

1권 6장 1절에서 블록 단위 I/O 원리를 설명하면서 Random 액세스와 Sequential 액세스의 차이점을 자세히 설명했다.

Sequential 액세스는 레코드간 논리적 또는 물리적인 순서를 따라 차례대로 읽어나가는 방식을 말하고, Random 액세스는 레코드간 논리적, 물리적인 순서를 따르지 않고 한 건을 읽기 위해 한 블록씩 접근하는 방식이라고했다. 그리고 I/O 튜닝의 핵심 원리로서 아래 두가지 항목을 꼽았다.

1. Sequential 액세스의 선택도를 높인다.
2. Random 액세스 발생량을 줄인다.

4절에서 테이블 Random 액세스 부하원리에 대해 설명했고, 5절과 6절에선 부하 해소 원리를 설명했는데, 이는 2번 항목에 해당한다.

지금부터는 1번 Sequential 액세스의 선택도를 높이는 방법에 대해 설명하려고 한다. 즉, 테이블을 액세스하기 전, 인덱스를 Sequential 방식으로 스캔하는 단계에서 발생하는 비효율 해소 원리를 다룬다.

| Sequential 액세스 선택도                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 일반적인 의미에서의 선택도는 전체 레코드 중에서 조건절에 의해 선택되는 비율을 말한다. 또한, 조나단 루이스는 그의 저서 "Cost-Based Oracle Fundamentals" 에서 인덱스 액세스에 대한 비용 공식을 쉽게 설명하려고 아래 두가지 용어를 도입하였으며, 4절에서 이미 소개한 바 있다.<br><br>- 유효 인덱스 선택도: 전체 인덱스 레코드 중에서 조건절을 만족하는 레코드를 찾기 위해 스캔할 것으로 예상되는 비율(%)<br>- 유효 테이블 선택도: 전체 레코드 중에서 인덱스 스캔을 완료하고서 최종적으로 테이블을 방문할 것으로 예상되는 비율(%)<br><br>조나단 루이스가 말하는 유효 테이블 선택도가 높다면 인덱스 스캔 후 테이블 Random 액세스 비율이 높은 것이므로 앞서 선택도가 높아야 효율적이라고 한 필자의 주장과 배치된다.<br><br>하지만 본절에서 말하는 Sequential 액세스 선택도는 인덱스를 스캔한 건수 중 결과로 선택되는 비율을 말하는 것이며, 그 비율이 높아야 효율적이라는 의미는 같은 결과 건수를 내기 위해 적은 양을 읽어야 함을 이르는 것이다. |

### (1) 비교 연산자 종류와 컬럼 순서에 따른 인덱스 레코드의 군집성

인덱스 스캔의 효율성을 설명하기에 앞서, 인덱스 레코드의 특성을 이해하는 게 필요하다.

테이블과는 다르게, 인덱스 레코드는 '같은 값을 갖는' 레코드들이 항상 서로 군집해 있다. 그러나 '같은 값'을 갖는 다'라고 하면 비교가 전제되므로, 만약 비교 연산자가 조건이 아닐 때는 인덱스 레코드도 서로 흩어진 상태일 수 있다. 그림 1-37을 보면서 이해해보자.

| 선두 컬럼, 선행 컬럼                                                                                                                                                                                                                                              |
| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 생각하기에 따라 같은 용어라고 해석될 수 있지만, 서로 헷갈리지 않도록 정리해보자. '선두 컬럼은 인덱스 구성상 맨 앞쪽에 있는 컬럼을 지칭할 때 사용하고, '선행 컬럼'은 상대적으로 앞쪽에 놓인 컬럼을 칭할 때 사용할 것이다. 선두 컬럼은 당연히 선행 컬럼에 포함된다. |

그림에서 리프 블록 아래 쪽에 있는 1부터 20까지의 숫자는 설명의 편의상 부여한 일련 번호다.

![](/assets/images/sqlp/sqlp2-01-07-1-img1-37.png)

여기서 우리는 한 가지 규칙을 발견할 수 있다. 선행 컬럼이 모두 '=' 조건인 상태에서 첫 번째 나타나는 범위 검색 조건까지만족하는 인덱스 레코드는 모두 연속되게 모여있지만, 그 이하 조건까지만족하는 레코드는 비교 연산자 종류에 상관없이 흩어진다(우연히 모여있을 수는 있음)는 규칙이다.

### (2) 인덱스 선행 컬럼이 등치(=) 조건이 아닐 때 발생하는 비효율

Sequential 액세스 효율은 선택도에 의해 결정된다. 다르게 표현하면, 같은 결과 건수를 내는데 얼마나 적은 레코드를 읽느냐로 효율성을 판단할 수 있다.

인덱스 Sequential 액세스에 따른 선택도는 인덱스 컬럼이 조건에 모두 등치(=) 조건으로 사용될 때가 가장 높다. 리프 블록을 스캔하면서 읽은 레코드는 하나도 필터링되지 않고 모두 테이블 액세스로 이어지기 때문이다. 따라서 인덱스 스캔 단계에서의 비효율은 전혀 없다.

인덱스 컬럼 중 일부가 조건절에서 생략되거나 조건이 아니더라도, 그것이 뒤쪽 컬럼일 때는 비효율이 없다.

반면에, 인덱스 선행 컬럼이 조건에 누락되거나 between, 부등호, like 같은 범위 검색 조건이 사용되면 인덱스를 스캔하는 단계에서 비효율이 발생한다.

인덱스 선행 컬럼이 모두 '조건일 때 필요한 범위만 스캔하고 멈출 수 있는 것은, 조건을 만족하는 레코드가 모두 한데 모여 있기 때문이다.

### (3) BETWEEN 조건을 IN-List로 바꾸었을 때 인덱스 스캔 효율

범위 점색 컬럼이 맨 뒤로 가도록 인덱스를 [아파트시세코드+평형+평형타입+인터넷매물] 순으로 변경하면 좋겠지만 운영 중인 시스템에서 인덱스 구성을 바꾸기는 쉽지 않다. 이럴 때 between 조건을 아래와 같이 IN-List로 바꿔주면 가끔 큰 효과를 얻는다.

IN-List 개수만큼 unional 브랜치가 생성되고, 각 브랜치마다 모든 컬럼을 조건으로 검색하기 때문에 앞서 선두 컬럼을 between 조건으로 비교할 때와 같은 비효율이 사라진다. 참고로, 3절에서 배운 IndexSkipScan 방식으로 유도하더라도 비슷한 효율을 얻을 수 있다.

#### between 조건을 IN-List 조건으로 바꿀 때 주의 사항

인덱스 선두 컬럼의 between 조건을 IN-List 조건으로 바꿀 때 주의할 점은, IN-List 개수가 많지 않아야 한다는 것이다. 그림1-39처럼 필요 없는 범위를 스캔하는 비효율은 사라지겠지만, 그림1-40처럼 인덱스 수직 탐색이 여러 번 발생하기 때문이다. IN-List 개수가 많을 때는, between 조건 때문에 리프 블록을 추가로 스캔하는 비효율 보다 IN-List 조건 때문에 브랜치 블록을 반복 탐색하는 비효율이 더 클 수 있고, 인덱스 높이(heigh)가 높을 때 특히 그렇다. (경우에 따라서는 인덱스 수직 탐색 과정에서의 일량도 상당하다. 그림1-2와 설명 참조)

인덱스 스캔 과정에서 선택되는 레코드들이 서로 멀리 떨어져 있을 때만 유용하다는 사실도 기억하기 바란다. between 조건인 선행 컬럼 때문에 많은 인덱스 리프 블록을 스캔하지만 거기서 선택되는 레코드는 소량일 때라야 IN-List로의 변환이 효과를 낸다. 왜냐면, 많은 레코드를 스캔하는 비효율이 있을지언정 블록 I/O 측면에서는 대개 소량에 그치는 경우가 많기 때문이다. 인덱스 리프 블록에는 테이블 블록과 달리 매우 많은(8KB 블록 기준으로 대략 수백개) 레코드가 담긴다.

### (4) Index Skip Scan을 이용한 비효율 해소

인덱스의 선두 컬럼이 누락됐을 때뿐만 아니라 부등호, between, like 같은 범위 검색 조건일 때도 인덱스 스킵 스캔이 유용하게 사용될 수 있고, 데이터 상황에 따라서는 조건 컬럼들을 인덱스 선두에 위치시킨 것에 버금가는 효과를 얻는다.

이 쿼리를 위해서라면 '조건인 판매구분이 선두 컬럼에 위치하도록 아래와 같이 인덱스를 구성하는 것이 가장 효과적이다.

마지막 시도로서, 인덱스 스킵 스캔으로 유도해보자.

![](/assets/images/sqlp/sqlp2-01-07-4-index-skip-scan1.png)

인덱스의 선두 컬럼이 between 조건임에도 큰 비효율 없이 단 300 블록만 읽고 일을 마쳤다. 아래 표는 네 가지 테스트 결과를 요약한 것인데, 인덱스 스킵 스캔이 IN-List보다 오히려 나아고 [판매구분+판매월] 순으로 구성된 인덱스를 사용할 때와 비교해서도 별 차이가 없다.

![](/assets/images/sqlp/sqlp2-01-07-4-table1.png)

선두 컬럼이 between이어서 나머지 검색 조건을 만족하는 데이터들이 서로 멀리 떨어져 있을 때가, 인덱스 스킵 스캔으로써 효과를 볼 수 있는 전형적인 케이스다(불필요한 리프 블록에 대한 액세스를 Skip하고 가능성 있는 리프 블록으로 점프하는 그림 1-10 참조).

### (5) 범위 검색 조건을 남용할 때 발생하는 비효율

지금까지 between을 중심으로 설명했는데, 여기서는 like 조건을 기준으로 설명을 진행하겠다. like도 between일 때와 기본 원리는 같고, 다만 스캔 범위에 약간의 차이가 생긴다. 이에 대해서는 바로 다음 항에서 설명한다.

사용자 선택에 따라 조건절이 다양하게 바뀔 때 SQL을 간편하게 작성하려고 조건절을 모두 like로 구사하는 개발팀을 종종 보는데, 해당 컬럼이 인덱스 구성 컬럼일 때는 주의가 필요하다.

이처럼 코딩을 쉽게 하려고 인덱스 컬럼에 범위 검색 조건을 남용하면 첫 번째 범위 검색 조건에 의해 스캔 범위가 대부분 결정되며, 그 다음을 따르는 조건부터는 스캔 범위를 줄이는 데에 크게 기여하지 못하므로 성능상 불리해질 수 있다.

스캔량이 적을 때는 그 차이가 미미하지만 대량일 때는 상당한 속도 차이를 보일 수 있다. 따라서 SQL을 작성할 때 주의가 요구되며, 인덱스 컬럼에 대해 비교 연산자를 신중하게 선택해야 하는 이유다.

| 범위 검색 조건만으로 구성된 쿼리 튜닝 사례                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 오래 전에 골택시 관제 시스템을 튜닝한 적이 있다. 운행 중인 택시들로부터 10초마다 송신되어온 위치 정보를 데이터베이스에 저장하고 있다가 고객으로부터 콜(Call)이 오면 반경 1km 이내의 가장 가까운 택시에게 신호를 보내는 시스템이다. 이 서비스를 위해 사용된 쿼리는 아래와 같다.<br><br>![](/assets/images/sqlp/sqlp2-01-07-5-sql3-1.png)<br>![](/assets/images/sqlp/sqlp2-01-07-5-sql3-2.png)<br><br>그리고 인덱스 구성은 다음과 같다.<br><br>![](/assets/images/sqlp/sqlp2-01-07-5-index1.png)<br><br>우편번호 테이블과 조인하는 부분도 비효율이 있어서 튜닝했지만, 여기서 설명하고자 하는 핵심 내용인 아래 gis 데이터 쿼리 부분만 따로 떼서 분석해보자. 여기서 쓰인 숫자 1은 1km를 의미한다.<br><br>![](/assets/images/sqlp/sqlp2-01-07-5-sql4.png)<br><br>특징적인 것은, 조건절이 모두 between 범위 검색 조건이라는 사실이다. 따라서 인덱스 스캔 범위는 인덱스 선두 컬럼인 9 19\_위도'컬럼에 대한 between 조건에 의해 거의 결정된다.<br><br>데이터 분포를 살펴보자. gis 데이터 테이블에는 당일치만 보관(전일 데이터는 백업 후 곧바로 삭제)하므로 당일 영업이 시작되는 시점에는 조회 속도가 아주 빠르다. 하지만 시간이 흘러 밤늦은 시간이 되면, 고객의 특정 위치 기준으로 위도 상 좌우 1km 이내에 평균 100만개 레코드가 쌓여 매우 느려진다. gis 위도 컬럼에 대한 between 조건에 의해 인덱스를 스캔해야 할 건수가 10만 건이나 되니 당연하지 않겠는가.<br><br>어떻게 튜닝하면 좋을까? 지금까지 설명한 인덱스 스캔 원리상 현재 데이터 모델로는 과도한 인덱스 스캔 범위를 줄일 방법은 없다.<br><br>여러 가지 고민을 하던 차에 필자와 같이 튜닝에 참여했던 동료 컨설턴트가 아이디어를 냈다. 반경 1km 이내를 한 번에 조회하지 말고 50m, 200m, 1<br><br>km 순으로 나눠서 쿼리하자는 것이다. 어차피 가장 가까운 데 위치한 하나의 택시를 찾는 게 목적이므로 그렇게 세 구간으로 나누어 쿼리하면 대부분 첫 번째 쿼리에서 찾게 된다. 따라서 기존보다 인덱스 스캔량을 1/20로 줄일 수 있어 쿼리 성능을 그만큼 향상시킬 수 있다.<br><br>실제 적용해보니 아주 성공적이었다. 아래는 반경 50m 이내에서 가장 가까운 곳에 위치한 택시를 찾는 쿼리다.<br><br>![](/assets/images/sqlp/sqlp2-01-07-5-sql5.png)<br><br>반경 200m와 1km 이내에서 가장 가까운 택시를 찾을 때는 0.05를 각각 0.2와 1로 바꿔주기만 하면 된다.<br><br>우편번호와 조인하는 부분도 눈여겨볼 필요가 있는데, 최종 건수는 항상 한 건이므로 미리 조인하지 않고 죄송한 건에 대해서만 조인하도록 변경하였다.<br><br>1권 5장에서 설명했던 데이터베이스 Call 최소화 원리에 따르면 여러 개로 나누어 실행하던 SQL을 하나로 통합하는 것이 효과적이다. 하지만 여기서는 거꾸로 하나의 SQL로 처리하던 것을 두 번, 세 번 나누어 처리함으로써 성능을 개선한 재미있는 사례다. |

### (6) 같은 컬럼에 두 개의 범위 검색 조건 사용 시 주의사항

앞에서는 다른 컬럼에 각각 범위 검색 조건을 사용하는 경우를 살펴봤는데, 같은 컬럼에 두 개의 범위 검색 조건을 사용할 때도 세심한 주의가 필요하다.

도서 조회용 프로그램을 개발 중이라고 하자. 예를 들어 '오라클'을 키워드로 입력하면, '오라클'로 시작하는 모든 도서가 조회되어야 한다. 한 화면에 10개씩 출력되도록 하는 것이 업무 요건이면, 흔히 아래와 같은 패턴으로 SQL을 작성한다(스크립트 ch1.14, kt 참조).

![](/assets/images/sqlp/sqlp2-01-07-6-sql1.png)

도서명 컬럼에 인덱스가 있다면 첫 번째 rownum 조건(rownum <= 100)에 해당하는 레코드만 읽고 멈출 수 있다. count(stopikey) 오퍼레이션이 작용하기 때문이며, 사용자들이 앞쪽 일부 레코드만 주로 본다면 위 쿼리도 만족스런 속도를 보인다. 표준적인 페이지 처리 구현 패턴으로 가장 적당하다고 하겠다.

그런데 뒤쪽 어느 페이지로 이동해도 빠르게 조회되도록 구현해야 한다면? 앞쪽 레코드를 스캔하지 않고 해당 페이지 레코드로 바로 찾아가도록 해야 하는데, 아래는 첫 번째 페이지를 출력하고 나서 '다음' 버튼을 누를 때의 구현 예시다.

![](/assets/images/sqlp/sqlp2-01-07-6-sql2-1.png)
![](/assets/images/sqlp/sqlp2-01-07-6-sql2-2.png)

그런데 SQL에 비효율이 없어 보이는 데도 union all 아래쪽 인덱스 스캔 단계에서만 377개 블록을 읽었다. 이유는, 도서명에 대한 범위 검색 조건이 두 개인데 그 중 like 조건을 인덱스 액세스 조건으로 사용했기 때문이다.

사용자가 키워드로 입력한 '오라클' 도서를 처음부터 스캔하다가 last_book_nmi보다 큰 9개 레코드를 찾고서야 멈추었고, 사용자가 뒤쪽 페이지로 많이 이동할수록 그 비효율은 점점 커진다.

해결 방안은? '도서명 > last_book_nmi' 조건이 인덱스 액세스 조건으로 사용되도록 하면 된다.

부등호 조건을 만족하는 첫 번째 레코드부터 스캔을 시작했기 때문에 인덱스에서 스캔한 블록 수가 단 2개로 줄었다.

#### OR-Expansion을 이용하는 방법과 주의사항

아래처럼 use_concat 힌트를 사용하면 union all을 사용할 때보다 SQL 코딩량을 줄일 수 있다. OR 조건에 대한 expansion(unional 분기)이 일어나면 뒤쪽 조건이 먼저 실행된다는 특징을 이용한 것이다.

주의할 점은, 버전에 따라 실행되는 순서가 달라진다는 사실이다. 9i까지는 I/O 비용 모델, CPU 비용 모델을 불문하고 뒤쪽에 있는 조건값을 먼저 실행하지만 10g CPU 비용 모델에서는 계산된 카디널리티가 낮은 쪽을 먼저 실행한다.

따라서 10g에서 값 분포에 상관없이 항상 뒤쪽에 있는 조건식이 먼저 처리되도록 하려면 ordered_predicates 힌트를 명시해야 한다. 자세한 설명은 4장 12절(3) 항 '조건절 비교 순서'를 참조하기 바란다.

#### rowid를 concatenation 하면 결과에 오류 발생

첫 페이지에서 출력한 마지막 rowid보다 큰 값으로 조회하는데, 문자형으로 변환되는 바람에 비교되는 값들의 순서가 서로 역전된다면 쿼리 결과 집합이 틀려질 수 있음을 이해하겠는가?

#### 인덱스를 스캔하면서 rowid를 필터링할 때 발생하는 비효율

rowid를 이용한 액세스이므로 비효율 없이 항상 완벽한 속도를 보장할 거 같지만 그렇지 않다. rowid를 가지고는 조건으로 바로 액세스할 땐 어떤 액세스보다 빠르지만 인덱스를 스캔하면서 rowid를 필터링할 때는 아니다.

인덱스 rowid는 리프 블록에만 있기 때문에 이를 필터링하려면 일단 다른 액세스 조건만으로 리프 블록을 찾아가야 한다. 거기서 스캔을 시작해 rowid를 필터링해야 하므로 '도서' 테이블에 같은 도서명을 가진 레코드가 "아주" 많다면 뒷 페이지로 이동할수록 비효율도 커진다.

비효율 없는 가장 완벽한 구현을 위해서라면 도서명idx 인덱스 뒤쪽에 도서번호(PK컬럼)를 붙이고 쿼리를 아래와 같이 바꾸면 된다.

하지만 인덱스 뒤에 PK컬럼을 붙여가며 개발하는 것이 쉽지만은 않다. 더구나 PK가 다중 컬럼으로 구성된다면 구현하기가 더 복잡해진다. 따라서 중복값이 아주 많은 경우가 아니라면 rowid를 이용하는 방안이 현실적이다.

### (7) Between과 Like 스캔 범위 비교

월별로 집계된 테이블에서 2009년 1월부터 12월 데이터를 조회하고자 할 때 흔히 아래와 같이 like 연산자를 사용한다.

```sql
select * from 월별고객별판매집계
where 판매월 like '2009%';
```

원래 아래와 같이 between 연산자를 사용하는 것이 더 정확한 방식임에도 개발자들이 like를 더 선호하는 이유는 간단하다. like로 코딩하는 것이 더 단순하고 쉽기 때문이다.

```sql
select * from 월별고객별판매집계
where 판매월 between '200901' and '200912';
```

like와 between은 둘 다 범위 검색 조건으로서, 앞에서 설명한 범위 검색 조건을 사용할 때의 비효율 원리도 똑같이 적용된다. 하지만 검색을 위해 입력한 값과 테이블의 실제 데이터 상황에 따라 둘 간의 인덱스 스캔량이 달라질 수 있다. 결론부터 말해, between을 사용한다면 적어도 손해볼 일은 없다. (6장 2절에서 보겠지만 Range 파티션 테이블을 쿼리할 때도 like 보다 가능한 between 연산자를 사용하는 편이 낫다.)

between 연산자를 사용한 쿼리는, 2009년 2월 데이터는 모두 읽더라도 2009년 1월 데이터 만큼은 판매구분이 B인 데이터만 읽는다. 반면 like 연산자를 사용한 쿼리는 2009년 1월과 2월 데이터를 모두 읽어야 한다. 쿼리가 1월 데이터를 모두 스캔한 이유는, 리프 블럭에 실제 없는 값(2009)으로 조회했기 때문이다.

#### 범위검색 조건의 스캔 시작점 결정 원리

지금부터 설명할 인덱스 스캔 시작점 결정 원리는 이해하기 쉽지 않은 내용이다. 정확한 원리를 이해하지 못하더라도 대충 어떤 의미인지를 파악하는 것만으로 충분하다고 하겠으며, 결론부터 말하면 범위 검색 조건 뒤를 따르는 조건은 스캔 범위를 줄이는 데에 영향을 미칠 수도 있고 그렇지 않을 수도 있다. 사용자가 조건 비교를 위해 입력한 값이나 테이블의 실제 데이터 상황에 따라 달라지며, 적어도 between이 like보다 더 넓은 범위를 스캔하는 경우는 없으므로 가능한 between을 사용하기 바란다는 내용이다.

인덱스 컬럼 조건에 대해 범위 검색 조건이 나타나면 이후 조건은 인덱스 스캔 범위를 줄여주지 못해 비효율이 생긴다. 하지만 방금 전에 설명했듯이 범위 검색 조건 뒤에 사용된 조건들도 제한적이나 마스캔 범위를 줄이는 데에 기여할 수 있는데, 지금부터 그 원리를 살펴보자.

먼저, 1절에서 설명한 인덱스 구조와 탐색 원리를 다시 한 번 상기하기 바란다. 그 중에서도 그림 1-2와 그에 대한 설명을 정확히 이해해야만 스캔 시작점 결정 원리를 이해할 수 있다.

여기서 키포인트는 실제 테이블에 존재하는 값을 수직적 탐색 조건으로 사용했다는 점이다. 만약 같은 between이더라도 쿼리6과 같이 실제 테이블에 없는 데이터 값을 입력하고 조회한 경우에는 200812'1|B인 레코드가 담긴 가장 마지막 리프 블록부터 스캔을 시작하게 되므로 불필요하게 2009011A' 구간까지 읽게 된다.

반대로, like 조건이더라도 쿼리7과 같이 실제 테이블에 있는 데이터 값을 입력하고 조회할 때는 판매구분='조건이 스캔 범위를 줄이는 데에 큰 역할을 하였다. 즉, 20090111A인 구간을 생략하고 20090111B' 구간 만 정확히 읽는다.
