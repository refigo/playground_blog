---
title: <오라클 성능 고도화 원리와 해법2> Ch01-08 인덱스 설계
date: 2024-04-08
categories: [Database, SQL Tuning]
tags: [SQLP]
---

## 오라클 성능 고도화 원리와 해법2 - Ch01-08 인덱스 설계

지금까지 다양한 인덱스 스캔 방식과 Random 액세스 최소화 원리, 스캔 효율화 원리에 대해 설명했다. 이제 이들 원리를 기초로 효과적인 인덱스 설계 방안은 무엇인지 설명하려고 한다.

SQL 각각을 위해 최적화된 인덱스를 모두 생성할 수 있다면 SQL 튜닝과 인덱스 설계만큼 쉬운 것도 없다. 하지만 그런 식으로 인덱스를 생성하다 보면 테이블마다 수십 개씩 달릴 것이 불보듯 뻔하고 관리 비용뿐만 아니라 시스템 부하를 가중시키는 원인이 된다. 인덱스 설계가 어려운 이유가 여기에 있으며, 시스템 전체를 바라보는 시각에서 전략적으로 접근하려는 노력이 무엇보다 중요하다고 하겠다.

인덱스를 구성할 때의 컬럼 순서 결정 원리부터 살펴보자.

### (1) 가장 중요한 두 가지 선택 기준

인덱스 스캔 방식에 여러 가지가 있지만 가장 정상적이고 일반적인 것은 Index Range Scan이라고 했다. 그리고 이를 위해서는 인덱스 선두 컬럼이 조건절에 반드시 사용되어야만 한다. 따라서 결합 인덱스를 구성할 때 첫 번째 기준은, 조건절에 항상 사용되거나, 적어도 자주 사용되는 컬럼들을 선정하는 것이다.

두 번째 기준은, 그렇게 선정된 컬럼 중 낮은 조건으로 자주 조회되는 컬럼을 앞쪽에 두어야 한다는 것이다. 그 이유에 대해서는 앞절에서 충분히 설명하였다.

아래 두 가지 선택 기준을 공식처럼 외우기 바란다.

1. 조건에 항상 사용되거나, 자주 등장하는 컬럼들을 선정한다.
2. 조건으로 자주 조회되는 컬럼들을 앞쪽에 둔다.

### (2) 인덱스 설계는 공식이 아닌 전략과 선택의 문제

앞서 제시한 두 가지 선택 기준이 일반적으로 통용될 수 있는 기본 공식임은 틀림없지만 인덱스 설계가 그렇게 간단하지는 않다. 오히려 이 공식을 지키려다보면 원칙과 기준이 없을 때처럼 인덱스 개수가 자꾸 늘어나게 됨을 느낄 것이다. 간단한 예제와 함께 설명해보자.

#### 간단한 설계 예제

모델링에 모범 답안은 있어도 정답은 없다고 흔히 얘기하듯이, 인덱스 설계에도 정답은 없다. 개별 쿼리 기준으로는 어떤 인덱스가 더 좋은지 명확히 구분할 수 있지만 시스템 전체적인 관점에서의 효율은 또 다른 기준, 즉 쿼리 수행 빈도, 업무 상 중요도, DML, 부하, 저장 공간, 관리 비용 같은 상황적 요소까지 고려해평가되어야 하기 때문이다.

그리고 그런 상황적 요소들을 해석하는 기준이 사람마다 다르기 때문에 설계자의 성향이나 스타일에 따라 결과물도 달라지게 마련이다. 그런 모든 요소들을 일일이 나열할 수 없으므로 독자 스스로가 가정을 세워가며 설계하기 바라고, 왜 그런 선택을 했는지 판단 근거를 제시할 수 있으면 된다.

#### 효율성 비교 분석

설계 방식에 따라 실제 효율성에 얼마나 차이가 생기는지 비교 분석해보자. 모든 스타일을 일일이 분석하기에는 지면이 부족하므로 양극에 놓인 두 개 스타일만 비교해보이려고 한다.

#### 스캔 효율성 이외의 판단 기준

쿼리 수행 빈도도 중요한 판단 기준이고, NL 조인의 Inner 쪽 테이블로서 자주 액세스 되는 지도 중요한 판단 기준이다.

데이터량도 중요한 판단 기준이다. 데이터량이 적다면 인덱스를 많이 만들더라도 저장 공간이나 트랜잭션 부하 측면에서 그다지 문제될 것이 없어 인덱스 구성 전략 때문에 크게 고민할 필요가 없다. 초대용량 테이블일 때는? 전문가의 손길이 필요하며, 진정한 튜닝 전문가는 이때 빛을 발한다.

「자주 사용되는 날 조건」이라는 애초의 기준은 인덱스 스캔의 효율성만을 고려한 것으로서, 실제 인덱스를 설계할 때는 시스템 전체적인 관점에서의 추가적인 요소들을 고려해야 한다. 그런 요소들을 열거해보면 다음과 같다.

- 쿼리 수행 빈도
- 업무 상 중요도
- 클러스터링 팩터
- 데이터량
- DML 부하(=기존 인덱스 개수, 초당 DML 발생량, 자주 갱신되는 컬럼 포함 여부 등)
- 저장 공간
- 인덱스 관리 비용 등

이런 상황적 요소에 대한 해석과 판단 기준이 서로 다르기 때문에 설계자의 성향이나 스타일에 따라 결과물도 크게 달라진다. 전장에서 똑같은 상황에 맞닥뜨리더라도 지휘관 스타일에 따라 전략과 전술이 달라지는 것처럼 말이다.

#### 인덱스 설계는 공식이 아닌 전략과 선택의 문제

인덱스 설계가 어려운 이유는, 개별 쿼리 성능뿐만 아니라 그 개수를 최소화함으로써 DML 부하를 줄이는 것까지 목표로 삼아야하기 때문이다. 따라서 시스템 전체적인 시각에서 대안 전략들을 수립하고, 그 중 최적을 선택할 수 있는 능력이 무엇보다 중요하다.

조건절 패턴이 10개 있을 때, 10개 패턴을 모두 만족하려고 인덱스를 10개나 만들 수는 없다. 그런 설계라면 몇 가지 공식만 가지고도 누구나 할 수 있다. 10개 중 최적을 달성해야 할 가장 핵심적인 액세스 경로(Critical Access Path) 한 두 개를 전략적으로 선택하고, 그것을 중심으로 나머지 액세스 경로는 약간의 비효율이 있더라도 목표한 성능 수준에 도달하도록 구성해주면 된다.

그리고 왜 그런 선택을 했는지, 전략적 판단 근거가 무엇인지 답할 수 있어야 한다. 단순한 공식에 의한 결정이 아니라 상황을 이해하고 나름의 판단 기준을 가지고 결정을 내리라는 것이다.

이처럼 전략적 선택을 통해 인덱스 개수를 최소한으로 유지한다면, 사용 빈도가 높거나, 중요한 액세스 경로가 새로 추가됐을 때 최적의 인덱스를 제공해줄 여유가 생긴다.

참고로, 지금까지 파티셔닝 기능은 배제한 채 설명했지만 실무적으로는 파티션 설계를 먼저 진행하거나 최소한 인덱스 설계와 병행하는 것이 바람직하다.

#### 인덱스 전략 수립을 위한 훈련

본 장에서 설명한 인덱스 원리를 차근차근 공부한 독자라면 지금쯤 전략적인 인덱스 설계에 필요한 기본기를 어느 정도 갖추었을 것으로 믿는다. 이제 수많은 훈련을 통해 자기만의 판단 기준과 선택 능력을 기르는 일만 남았다.

| 인덱스 설계 조정을 통한 튜닝 사례 - Right Growing 인덱스                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 인덱스에는 키값 기준으로 정렬된 상태를 유지하며 값이 입력되는다. 따라서 '일련번호' 나 입려일시' 처럼 순차적으로 증가하는 컬럼에 생성한 인덱스는 항상 맨 우측 블록으로만 값이 입력된다.<br><br>이런 특징을 갖는 인덱스를 'right-growing 인덱스' 라고 부르며, 여러 프로세스에 의한 동시 입력이 많을 때 트랜잭션 성능을 떨어뜨리는 주범이다. 입력값이 다르므로 로우락 경합은 발생하지 않지만 같은 블록을 갱신하려는 프로세스간 버퍼락 경합이 발생하기 때문이다. 이때 나타나는 대기 이벤트가 buffer busy waits라고 설명한 것을 1권을 본 독자라면 기억할 것이다.<br><br>이런 인덱스 경합은 의외로 흔히 발생하는 현상으로서 RAC 환경에서 특히 심각한 성능 저하를 일으키며, gc buffer busy 이벤트로 관찰된다. 여러 노드가 동시에 Current 블록 하나를 서로 주고받으며 값을 입력해야 하기 때문이다.<br><br>해결 방법으로는, Reverse Key 인덱스로 바꿔 블록이 분산되도록 하거나, 그보다 오라클이 권하는 솔루션으로서 인덱스를 해시 파티셔닝하는 방법이 있다. 해시 파티셔닝을 하면 값이 순차적으로 증가하더라도 해시 함수에서 리턴된 값에 따라 서로 다른 파티션에 입력되므로 경합을 그만큼 줄일 수 있다. |
