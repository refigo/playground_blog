---
title: <오라클 성능 고도화 원리와 해법2> Ch02-08 고급 조인 테크닉
date: 2024-04-22
categories: [Database, SQL Tuning]
tags: [SQLP]
---

## 오라클 성능 고도화 원리와 해법2 - Ch02-08 고급 조인 테크닉

### (1) 누적 매출 구하기

우선 아래와 같이 월별 지점 매출 테이블을 만들어보자(스크립트 ch2_11.txt 참조)

```sql
create table 월별지점매출 as
select deptno as "지점",
       row_number() over (partition by deptno order by empno) as "판매월",
       round(dbms_random.value(500, 1000)) as "매출"
from emp
order by deptno;
```

그림 2-23 좌측은 방금 만든 월별 지점 매출 테이블을 출력한 것이다.

![](/assets/images/sqlp/sqlp2-02-08-1-img2-23.png)

이제 월별 지점 매출을 이용해 그림 2-23 우측과 같은 형태의 누적 매출을 구하려고 한다. 각 지점 별로 판매 월과 함께 증가하는 누적 매출(running total)을 구하려는 것이다.

오라클 8i부터 제공되기 시작한 분석 함수(Analytic Function)를 이용하면 아래와 같이 간단하게 원하는 결과를 얻을 수 있다.

```sql
select 지점, 판매월, 매출,
       Sum(매출) over (partition by 지점 order by 판매월 range between unbounded preceding and current row) as 누적매출
from 월별지점매출;
```

만약 분석 함수가 지원되지 않는 오라클 버전(또는 DBMS)을 사용하고 있다면 어떻게 해야 할까?

우리는 늘 ' = ' 연산자를 이용한 조인에만 익숙해져 있지만 업무에 따라서는 between, like, 부등호 같은 연산자로 조인해야 할 때도 있다. 아래는 부등호 조인을 통해 그림 2-23 우측과 같은 지점별 누적 매출을 구하는 방법을 예시하고 있다.

```sql
select t1.지점, t1.판매월, min(t1.매출) as 매출, Sum(t2.매출) as 누적매출
from 월별지점매출 t1, 월별지점매출 t2
where t2.지점 = t1.지점
and t2.판매월 <= t1.판매월
group by t1.지점, t1.판매월
order by t1.지점, t1.판매월;
```

### (2) 선분 이력 끊기

선분 이력 레코드를 가공해야 할 때가 있는데, 월말 기준으로 선분을 끊는 경우를 살펴보자. 본론으로 들어가기에 앞서, 두 선분이 겹치는 구간에 대한 시작일자 및 종료일자 선택 규칙에 대해 살펴보자.

시간을 나타내는 두 개의 선분이 서로 겹치는 모습을 표현하면 그림 2-24의 (a), (b), (c), (d)처럼 네 가지 패턴이 있다. (e), (f)는 참고로 그린 것이며, 서로 겹치지 않은 모습이다.

![](/assets/images/sqlp/sqlp2-02-08-2-img2-24.png)

점선 타원 표시는 두 선분이 겹치는 구간의 시작 및 종료 일자를 나타낸 것이다. 그리고 점선 화살 표는 시간의 진행 순서를 표시한 것이다.

(a), (b), (c), (d) 네 스타일의 특징과 겹치는 구간의 시작 및 종료 일자 선택 규칙을 정리하면, 아래 표와 같다. 설명의 편의를 위해, 그림 2-24에서 상단에 있는 선분의 시작일자와 종료일자를 각각 '시작일자1'과 '종료일자1'이라고 명명하였고, 하단에 있는 선분의 시작일자와 종료일자를 각각 '시작일자2'와 '종료일자2'라고 명명하였다.

![](/assets/images/sqlp/sqlp2-02-08-2-table1.png)

본론으로 들어가서, 그림 2-25처럼 월도와 선분이력 두 개의 테이블이 있을 때 선분 이력을 월도와 조인해서 맨 아래 쪽 변환된 선분 이력과 같은 형태로 만들려고 한다. 즉, 두 개 이상의 월도에 걸친 선분(5, 7)을 매 월말 기준으로 끊으려는 것이다.

![](/assets/images/sqlp/sqlp2-02-08-2-img2-25.png)

그리고 그림과 표를 자세히 분석하면 좀 더 간단한 규칙을 발견할 수 있는데, 겹치는 구간의 시작일자는 두 시작일자 중 큰 값을 취하면 되고 종료일자는 두 종료일자 중 작은 값을 취하면 된다.
따라서 최종적으로는 아래와 같이 쿼리하는 것이 가장 좋다.

```sql
select b.상품번호,
       greatest(a.시작일자, b.시작일자) as 시작일자,
       least(a.종료일자, b.종료일자) as 종료일자,
       b.데이터
from 월도 a, 선분이력 b
where b.시작일자 = a.종료일자
and b.종료일자 >= a.시작일자;
```

### (3) 데이터 복제를 통한 소계 구하기

쿼리를 작성하다보면 데이터 복제 기법을 활용해야 할 때가 많다. 방금 두 사례는 부등호 조인을 이용한 데이터 복제 방법이었는데, 일부러 카티션 곱(Cartesian Product)을 발생시켜 복제하기도 한다. 전통적으로 많이 쓰던 방식은 아래와 같은 복제용 테이블(copy)을 미리 만들어두고 이를 활용하는 것이다.

```sql
create table copy_t ( no number, no2 varchar2(2));

insert into copy_t
select rownum, lpad(rownum, 2, '0') from all_tables where rownum <= 31;

alter table copy_t add constraint copy_t_pk primary key (no);
create unique index copy_t_no_idx on copy_t (no2);
```

이제 아래 쿼리를 수행하면 emp 테이블에 있는 14개 레코드가 3개씩 총 42개로 복제된다.

```sql
select * from emp a, copy_t b
where b.no < 3;
```

오라클 9i부터는 dual 테이블을 사용하면 편하다. 아래와 같이 dual 테이블에 start with 절 없는 connect by 구문을 사용하면 두 개의 집합이 자동으로 만들어진다.

```sql
select rownum no from dual connect by level <= 2;

        NO
----------
         1
         2
```

이 방법을 사용해 emp 테이블을 복제하는 방법은 아래와 같다.

```sql
select * from emp a, (select rownum no from dual connect by level < 2) b;

......

28 개의 행이 선택되었습니다.
```

데이터 복제 기법을 활용하면 아래와 같이 단일 SQL로도 부서별 소계를 구할 수 있다.

![](/assets/images/sqlp/sqlp2-02-08-3-sql1.png)

이처럼 group by를 잘 구사하면 우리가 원하는 데이터 집합을 자유자재로 가공해낼 수 있다.
아래는 세 개로 복제하고서 총계까지 구하는 사례다.

![](/assets/images/sqlp/sqlp2-02-08-3-sql2.png)

물론 표준 rollup 구문을 사용하면 데이터 복제 기법을 쓰지 않고도 아래와 같이 간편하게 소계 및 총계를 구할 수 있다.

![](/assets/images/sqlp/sqlp2-02-08-3-sql3-1.png)
![](/assets/images/sqlp/sqlp2-02-08-3-sql3-2.png)

### (4) 상호 배타적 관계의 조인

어떤 엔티티가 두 개 이상의 다른 엔티티의 집합과 관계(Relationship)를 갖는 것을 '상호 배타적(Exclusive OR) 관계'라고 한다. 그림2-26에서 상품권 결제 테이블과 온라인권 및 실권 테이블과의 관계가 여기에 해당하며, 관계선에 표시된 아크(arc)를 확인하기 바란다.

![](/assets/images/sqlp/sqlp2-02-08-4-img2-26.png)

그림2-26과 같은 데이터 모델을 실제 데이터베이스로 구현할 때, 상품권 결제 테이블에는 아래 두 가지 방법 중 하나를 사용한다.

1. 온라인권번호, 실권번호 두 컬럼을 따로 두고, 레코드별로 둘 중 하나의 컬럼에만 값 입력한다.
2. 상품권구분과 상품권번호 컬럼을 두고, 상품권구분이 1일 때는 온라인권번호를 입력하고 2일 때는 실권번호를 입력한다.

1번처럼 설계할 때는 아래와 같이 Outer 조인으로 간단하게 쿼리를 작성할 수 있다.

```sql
select /*+ ordered use n1 (b) use n1 (e) use 1n (d) */ a.주문번호, a.결제일자, a.결제금액
, nvl( b. 온라인권번호, c.실권번호) 상품권번호
, nvl(b.발행일시, d.발행일시) 발행일시
from
상품권결제a, 온라인권b, 실권c, 실권발행d
where
a.결제일자 between :dt1 and :dt2
and
b.온라인권번호(+) = a.온라인권번호
and
c.실권번호(+) = a.실권번호
and
d.발행번호(+) = c.발행번호;
```

2번처럼 설계했을 때는 약간의 고민이 필요한데, 가장 쉽게 생각할 수 있는 방법은 아래와 같이 union all을 이용하는 것이다.

```sql
select x.주문번호, x.결제일자, x.결제금액, y.온라인권번호 상품권번호, y.발행일시 from
상품권결제x, 온라인권y
where x.상품권구분= '1'
and
x.결제일자 between :dt1 and :dt2
and
y.온라인권번호 = x.상품권번호
union all
select x.주문번호, x.결제일자, x.결제금액, y.실권번호 상품권번호, z.발행일시 from
상품권결제x, 실권y, 실권발행z
where x.상품권구분= '2'
and
x.결제일자 between :dt1 and :dt2
and
y.실권번호 = x.상품권번호
and
z.발행번호 = y.발행번호;
```

union all을 중심으로 쿼리를 위아래 두번 수행했지만 만약 [상품권구분+결제일자] 순으로 구성된 인덱스를 이용한다면 읽는 범위에 중복은 없다. 하지만 [결제일자+상품권구분] 순으로 구성된 인덱스를 이용할 때는 인덱스 스캔 범위에 중복이 생기고, [결제일자]만으로 구성된 인덱스를 이용한다면 상품권구분을 필터링하기 위한 테이블 Random 액세스까지 중복해서 발생할 것이다.

그럴 때는 아래와 같이 쿼리함으로써 중복 액세스에 의한 비효율을 해소할 수 있다.

```sql
select /*+ ordered use n1 (b) use n1 (c) use n1 (d) */
a.주문번호, a.결제일자, a.결제금액
, nvl( b.온라인권번호, c.실권번호) 상품권번호
, nvl(b.발행일시, d.발행일시) 발행일시
from 상품권결제a, 온라인권b, 실권c, 실권발행d
where a.결제일자 between :dt1 and :dt2
and
b.온라인권번호(+) = decode(a.상품권구분, 1, a.상품권번호)
and
c.실권번호(+) = decode(a.상품권구분, 2, a.상품권번호)
and
d.발행번호(+) = c.발행번호;
```

### (5) 최종 출력 건에 대해서만 조인하기

아래는 화면 페이지 처리 시 흔히 사용되는 방식이다.

```sql
SELECT * FROM
(
  SELECT A.등록일자, A.번호, A.제목, B.회원명, C.게시판유형명, D.질문유형명,
  COUNT(*) OVER() TOTAL_COUNT
  FROM 게시판 A, 회원 B, 게시판유형 C, 질문유형 D
  WHERE A.게시판유형 = :TYPE
  AND B.회원번호 = A.작성자번호
  AND C.게시판유형 = A.게시판유형
  AND D.질문유형 = A.질문유형
  ORDER BY A.등록일자 DESC, A.질문유형, A.번호
)
WHERE ROWNUM <= 31
AND NO BETWEEN 21 AND 30;
```

전체 게시판 데이터는 수백만 건이고, 특정 게시판 유형(게시판유형=:TYPE)에 속하는 데이터는 평균 10만 건에 이른다. 게다가 회원, 게시판 유형, 질문 유형 3개 테이블과의 조인까지 수행하므로 성능이 좋을 리 없다. 인덱스 구성은 아래와 같아서 소트 오퍼레이션이 불가피하다.

≫ 게시판X01: 게시판유형 + 등록일자DESC + 번호

아래 실행 계획을 보면, 10만 건을 읽어 나머지 세 테이블과의 조인을 모두 완료한 후에 소트 단계에서 stopkey가 작동(id=5)하고 있다.

![](/assets/images/sqlp/sqlp2-02-08-5-EP1.png)

튜닝을 위해 게시판XO1인덱스에 질문유형 컬럼을 추가하자. 인덱스 컬럼 순서를 바꾸는 결정을 하기는 쉽지 않지만 뒤쪽에 추가하는 것은 그다지 어렵지 않다.

≫ 게시판X01: 게시판유형 + 등록일자DESC + 번호 + **질문유형**

위처럼 인덱스를 구성했다면 이제 게시판 테이블로부터 '게시판유형=:TYPE' 조건에 해당하는 레코드를 찾는 작업은 인덱스 내에서 해결 가능하다. 아래처럼 인덱스만 읽도록 쿼리를 작성해 보자.

```sql
SELECT ROWID RID
FROM 게시판
WHERE 게시판유형 = :TYPE
ORDER BY 등록일자 DESC, 질문유형, 번호;
```

읽은 레코드를 정렬하는 작업은 피할 수 없지만, 인덱스 블록만 읽으면 되기 때문에 이전보다 훨씬 빠르게 수행될 것이다.

다른 세 개 테이블과의 조인 컬럼, 그리고 Select-list에서 참조되는 컬럼을 어떻게 읽어올 것인지가 문제인데, 이들 컬럼은 페이지 처리가 모두 완료돼 최종 결과 집합으로 확정된 10 건에 대해서만 액세스하면 된다. 그럴 목적으로 인덱스를 스캔할 때 rowid 값을 같이 읽어온 것이다. 최종적으로 완성된 쿼리는 아래와 같다.

![](/assets/images/sqlp/sqlp2-02-08-5-sql1-1.png)
![](/assets/images/sqlp/sqlp2-02-08-5-sql1-2.png)

게시판 테이블을 두 번 읽도록 쿼리를 작성했지만 인라인 뷰 내에서는 인덱스만 읽도록 했고, 두 번째 게시판 테이블(A)을 액세스할 때는 앞서 읽은 rowid 값으로 직접 액세스하기 때문에 인덱스를 경유해 한 번만 테이블을 액세스하는 것과 같은 일량이다. 실행 계획에 TABLE ACCESS BY INDEX ROWID가 아니라 TABLE ACCESS BY USER ROWID로 표시된 것에 주목하자.

회원, 게시판 유형, 질문 유형 테이블과의 조인 컬럼인 작성자번호, 게시판 유형, 질문 유형이 Null 허용 컬럼일 때는 결과가 달라지지 않느냐고 반문하는 독자가 있을 것이다. 예리한 질문이다.

우선, 실제 Null 값이 존재하는지 확인해봐야 한다. 업무적으로 Null 값이 허용되지 않는데도 컬럼에 Not null 제약을 설정하지 않는 경우가 매우 흔하기 때문이다.

두 번째는, 이들 컬럼이 Null 값이라고 해서 게시판 출력 리스트에서 제외되는 것이 업무적으로 맞는지 확인해볼 필요가 있다. 아마도 Outer 조인을 해야 옳은데, 개발자가 간과한 경우일 수 있다. 필자가 튜닝 결과서를 개발팀에 전달하면서 확인해보면 많은 경우가 그랬다. 그렇다면, 위 쿼리에 아래처럼 Outer 기호(+)만 붙여주면 된다.

```sql
WHERE X.NO BETWEEN 21 AND 30 AND A.ROWID = X.RID
AND B.회원번호(+) = A.작성자번호
AND C.게시판유형(+) = A.게시판유형
AND D.질문유형(+) = A.질문유형
```

만약 업무적으로 그런 레코드를 제외하길 원한다면, Null 값을 허용하는 조인 컬럼들에 대해 인라인 뷰 안에 아래처럼 is not null 조건을 추가해주어야 한다.

```sql
WHERE 게시판유형 = :TYPE
AND 작성자번호 IS NOT NULL
AND 게시판유형 IS NOT NULL
AND 질문유형 IS NOT NULL
```

조건절을 추가하는 것은 어렵지 않지만 이들 컬럼도 인덱스 구성에 포함해주어야 하므로 추가적인 고민이 필요하다.

인덱스만 읽고 페이지 처리되도록 유도할 수 있으면 좋지만 이렇게 컬럼이 많아져 인덱스 조정이 여의치 않을 때는, 아래처럼 차선책을 택하는 것을 고려해볼 수 있다.

```sql
SELECT /*+ ORDERED USE NL (B) USE NL (C) USE NL (D) */
A.등록일자, B.번호, A.제목, B.회원명, C.게시판유형명, D.질문유형명, A.CNT FROM
(SELECT A.*, ROWNUM NO, COUNT (*) OVER () CNT FROM
(SELECT 등록일자, 번호, 제목, 작성자번호, 게시판유형, 질문유형 FROM 게시판
WHERE 게시판유형 = :TYPE
AND
작성자번호 IS NOT NULL
AND
게시판유형 IS NOT NULL
AND
질문유형 IS NOT NULL
ORDER BY 등록일자 DESC, 질문유형, 번호
) A
WHERE ROWNUM <= 31
) A, 회원B, 게시판유형C, 질문유형D WHERE A.NO BETWEEN 21 AND 30
AND B.회원번호 = A.작성자번호
AND C.게시판유형 = A.게시판유형
AND D.질문유형 = A.질문유형
```

앞에서는 게시판 테이블을 처음 액세스할 때 인덱스 컬럼과 rowid만 읽었지만 여기서는 테이블까지 액세스하도록 했으므로 전체를 읽어 정렬하는 부하는 피할 수 없다. 하지만, 불필요한 조인 횟수를 줄이는 것만으로도 상당한 성능 개선 효과를 얻을 수 있다.

#### 반정규화는 성능을 위한 최후의 수단

정규화된 모델로는 제대로 성능을 내기 어려울 때만 반정규화를 단행하는 게 관계형 데이터베이스를 구현하는 정석이야. 그럼에도 성능이 좋지 않을 것을 예단하고 논리 데이터 모델링 단계에서 미리 반정규화를 실시하는 설계자나 개발팀을 자주 봐. 더 큰 문제는, 같이 프로젝트를 한 후배 개발자들이 그것을 답습하고 으레 그렇게 설계하는 것이 정석이라고 여긴다는 사실이다.

![](/assets/images/sqlp/sqlp2-02-08-5-img2-27.png)

예를 들어, 업무 연락 메시지 게시판을 구현하기 위한 데이터 모델을 열어보면 열 받을 발송 메시지 건수, 수신인 수 같은 추출(derive) 속성들이 설계돼 있다.

![](/assets/images/sqlp/sqlp2-02-08-5-img2-28.png)

만약 그런 업무를 아래와 같은 SQL 패턴으로 개발했다면 수신 확인자 수와 수신 대상자 수를 세고 새글 여부를 확인하는 스칼라 서브쿼리 때문에 성능 문제를 겪었을 거야. 이를 해결하지 못 하 면 그림 2-28처럼 설계 하 게 마련이다.

```sql
SELECT ...
FROM (
    SELECT ...
    FROM (
        SELECT
            a.발신자ID,
            a.발송일시,
            a.제목,
            b.사용자이름 AS 보낸이,
            (SELECT COUNT(수신일시) FROM 메시지수신인 ...) AS 수신확인자수,
            (SELECT COUNT(*) FROM 메시지수신인 ...) AS 수신대상자수,
            (CASE WHEN EXISTS (
                    SELECT "x" FROM 메시지수신인
                    WHERE 발신자ID = a.발신자ID
                    AND 발송일시 = a.발송일시
                    AND 수신자ID = :로그인사용자ID
                    AND 수신일시 IS NOT NULL
                ) THEN 'Y' END
            ) AS 새글여부
        FROM 메시지 a, 사용자 b
        WHERE b.사용자ID = a.발신자ID
        ORDER BY a.발송일시 DESC
    ) a
    WHERE ROWNUM <= 30
)
WHERE no BETWEEN 21 AND 30
```

위와 같은 추출 속성을 도입하면 메시지를 수신할 때마다 메시지 테이블의 수신인 수를 갱신해주는 DML, 프로그램도 같이 작성해야 해. 메시지 수신은 늘 일어나는 업무이기 때문에 빠뜨리 지 않고 구현하겠지만, 문제는 일상적이지 않은 업무 때문에 데이터 정합성이 훼손될 수 있다는 데에 있다. 예를 들어 사용자가 탈퇴하면 메시지 수신인 수도 일괄적으로 갱신해주어야 하는데, 그런 처리를 실수로 빠뜨리기 쉽다.

반정규화를 실시했으면 업무 규칙 누락이 생기지 않도록 꼼꼼히 점검해야 한다. 그보다는 반정규화 없이 성능 문제를 해결할 수 있다면 가장 좋다.

앞에서 설명했던 원리를 적용해 쿼리를 아래와 같이 바꾼다면 최종 출력되는 10 건에 대해서만 수신 정보와 새글 여부를 확인하기 때문에 굳이 추출 속성을 두지 않고도 성능 문제를 해결할 수 있다. 데이터베이스 설계자에게 DB 성능 원리에 대한 깊이 있는 연구가 필요한 이유가 여기에 있다.

```sql
SELECT a.발신자ID, a.발송일시, a.제목, b.사용자이름 AS 보낸이,
(SELECT COUNT(수신일시) / COUNT(*) FROM 메시지수신인) AS 수신확인,
(CASE WHEN EXISTS() THEN 'Y' END) AS 새글여부
FROM (
SELECT ROWNUM no,
FROM (
SELECT 발신자ID, 발송일시, 제목 FROM 메시지
ORDER BY 발송일시 DESC
) WHERE ROWNUM <= 30
) a, 사용자 b
WHERE a.no BETWEEN 21 AND 30
AND b.사용자ID = a.발신자ID
```
