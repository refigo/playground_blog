---
title: <오라클 성능 고도화 원리와 해법2> Ch07-01 병렬 처리 기본 개념
date: 2024-05-27
categories: [Database, SQL Tuning]
tags: [SQLP]
---

## 오라클 성능 고도화 원리와 해법2 - Ch07-01 병렬 처리 기본 개념

병렬 처리란, SQL문이 수행해야 할 작업 범위를 여러 개의 작은 단위로 나누어 여러 프로세스(또는 쓰레드)가 동시에 처리하는 것을 말한다(그림 7-1). 여러 프로세스가 동시에 작업하므로 대용량 데이터를 처리할 때 수행 속도를 극적으로 단축시킬 수 있다.

![](/assets/images/sqlp/sqlp2-07-01-img7-1.png)

병렬 처리와 관련해서 다루어야 할 개념, 원리, 규칙 등이 많지만, 이를 모두 설명하지는 않을 것이다. 필요하다면 오라클 온라인 매뉴얼을 먼저 참조하기 바란다. 본서에서는 오라클 매뉴얼에서 자세히 다루지 않지만 병렬 SQL 튜닝을 위해 반드시 이해해야 할 핵심 원리만을 설명한다.

### (1) Query Coordinator와 병렬 서버 프로세스

Query Coordinator(QC)는 병렬 SQL문을 발행한 세션을 말하고, 병렬 서버 프로세스는 실제 작업을 수행하는 개별 세션들을 말한다.

QC의 역할은 다음과 같다:

1. 병렬 SQL이 시작되면 QC는 사용자가 지정한 병렬도(DOP, degree of parallelism)와 오퍼레이션 종류에 따라 하나 또는 두 개의 병렬 서버 집합(Server Set)을 할당한다. 우선 서버 풀(Parallel Execution Server Pool)로부터 필요한 만큼 서버 프로세스를 확보하고, 부족분은 새로 생성한다.
2. QC는 각 병렬 서버에게 작업을 할당한다. 작업을 지시하고 일이 잘 진행되는지 관리·감독하는 작업반장 역할이다.
3. 병렬로 처리하도록 사용자가 지시하지 않은 테이블은 QC가 직접 처리한다. 예를 들어, 아래 실행 계획에서 dept 테이블을 직렬로 읽어 병렬 서버에 전송하는 8~9번 오퍼레이션은 QC의 몫이다.
4. QC는 각 병렬 서버로부터의 산출물을 통합하는 작업을 수행한다. 예를 들어 집계 함수(sum, count, avg, min, max 등)가 사용된 아래와 같은 병렬 쿼리를 수행할 때, 각 병렬 서버가 자신의 처리 범위 내에서 집계한 값을 QC에게 전송하면 QC가 최종 집계 작업을 수행한다.
5. QC는 쿼리의 최종 결과 집합을 사용자에게 전송하며, DML일 때는 갱신 건수를 집계해서 전송해준다. 쿼리 결과를 전송하는 단계에서 수행되는 스칼라 서브쿼리도 QC가 수행한다.

```sql
select /*+ ordered use_hash(d) full(d) full(e) noparallel(d) parallel (e 4) */
       count(*), min(sal), max(sal), avg(sal), sum(sal)
from dept d, emp e
where d.loc = 'CHICAGO'
and e.deptno = d.deptno;
```

![](/assets/images/sqlp/sqlp2-07-01-1-EP1-1.png)
![](/assets/images/sqlp/sqlp2-07-01-1-EP1-2.png)

병렬 처리에서 실제 QC 역할을 담당하는 프로세스는 SQL문을 발행한 사용자 세션 자신이다.

### (2) Intra-Operation Parallelism과 Inter-Operation Parallelism

```sql
select /*+ full(고객) parallel(고객 4) */ *
from 고객
order by 고객명;
```

그림 7-2는 order by를 포함하는 위 병렬 쿼리의 수행 과정을 도식화한 것이다.

![](/assets/images/sqlp/sqlp2-07-01-2-img7-2.png)

이해를 돕기 위해, 8명의 영업사원이 각자 관리하던 명함을 영업팀에서 통합 관리할 목적으로 명함 전체를 이름순으로 정렬하는 경우를 예로 들어보자. 두 가지 방법을 생각해볼 수 있는데, 첫 번째는 8명이 각자 자신의 것을 정렬하고 나면 영업팀에서 이를 최종적으로 머지(Merge)하는 것이다.

두 번째는, 두 개 조로 나누고 역할을 분담해서 서로 다른 작업을 동시에 진행하는 것으로서 그림 7-2와 같은 방식이다(QC는 영업팀장에 해당). 즉, 4명(분배 팀)은 명함을 분배하고, 다른 4명(정렬 팀)은 그것을 받아 정렬하는 역할만 하면 된다.

정렬 팀은 먼저 알파벳(또는 가나다) 순으로 각자 처리할 연속된 범위(A~G, H~M, N~S, T~Z)를 지정받는다. 분배 팀은 영업팀장으로부터 할당받은 명함 뭉치를 각자 들고 고객명에 따라 정해진 정렬 담당자에게 건넨다. 정렬 담당자는 4명의 분배자로부터 자신에게 건네진 명함만 정렬하면 되고, 나중에 이를 머지하는 작업은 아주 쉽다. 이미 정렬된 묶음을 영업팀장이 순서대로 받아서 포개어 놓기만 하면 된다(그림 7-2에서 QC가 이 역할을 담당).

첫 번째 방법은 작업자가 많을수록 나중에 영업팀장이 머지하는 단계에 부하가 걸려 병렬 처리를 극대화하기 어렵다. 오라클이 order by를 병렬로 처리할 때 두 번째 방식을 사용하는 이유다.

이때, 서로 배타적인 범위를 독립적으로 동시에 처리하는 것을 Intra-Operation Parallelism이라고 한다. 4명이 병렬로 자신이 할당받은 명함을 하나씩 상대편에 분배하는 첫 번째 작업과, 병렬로 각자 전달받은 명함을 정렬하는 두 번째 작업 모두 여기에 해당한다. 같은 조(서버 집합)끼리는 서로 데이터를 주고받을 일이 없다.

반면, 명함을 읽어 상대편 조(다른 서버 집합)에 분배하거나 정렬된 결과를 영업팀(QC)에게 전송하는 작업을 병렬로 동시에 진행하는 것을 Inter-Operation Parallelism이라고 하며, 이때는 항상 프로세스 간 통신이 발생한다.

### (3) 테이블 큐

Intra-Operation Parallelism은 한 병렬 서버 집합(Server Set)에 속한 여러 프로세스가 처리 범위를 달리하면서 병렬로 작업을 진행하는 것이므로, 집합 내에서는 절대 프로세스 간 통신이 발생하지 않는다. 반면, Inter-Operation Parallelism은 프로세스 간 통신이 발생하고, 메시지 또는 데이터를 전송하기 위한 통신 채널이 필요하다.

쿼리 서버 집합 간(P-P) 또는 QC와 쿼리 서버 집합 간(P-S, S-D) 데이터 전송을 위해 연결된 파이프라인(Pipeline)을 테이블 큐(Table Queue)라고 한다. 그리고 그림 7-3에서 보듯, 각 테이블 큐에 부여된 이름(:TQ10000, :TQ10001, :TQ10002 등)을 테이블 큐 식별자(TQ Identifier)라고 한다.

```sql
select /*+ ordered use_hash(e) full(d) noparallel(d) full(e) parallel(e 2)
           pq_distribute(e broadcast none) */
*
from dept d, emp e
where d.deptno = e.deptno
order by e.ename;
```

그림 7-3을 보면, 쿼리 서버 집합 간(P-P) Inter-Operation Parallelism이 발생할 때는 사용자가 지정한 병렬도(Degree of Parallelism = 2)의 배수(4개)만큼 서버 프로세스가 필요한 것을 알 수 있다. 또한 테이블 큐(:TQ10001)에는 병렬도의 제곱(2² = 4)만큼 파이프라인이 필요하다는 사실도 알 수 있다. 참고로 그림 7-2를 보면, 병렬도가 4이므로 8(=4X2)개의 서버 프로세스를 위해 16(=4²)개의 파이프라인이 형성되었다.

#### 생산자/소비자 모델

테이블 큐에는 항상 생산자(Producer)와 소비자(Consumer)가 존재한다. 그림 7-3을 보면, 처음 dept 테이블을 읽어 분배하는 :TQ10000에서는 QC가 생산자이고 서버 집합 1이 소비자이다. 이어지는 두 번째 테이블 큐 :TQ10001에서는 서버 집합 1이 생산자가 되고, 서버 집합 2가 소비자가 된다. 마지막으로, 정렬된 최종 결과 집합을 전송하는 :TQ10002에서는 서버 집합 2가 생산자가 되고 QC가 소비자가 된다. select 문장에서의 최종 소비자는 항상 QC이다. 그림 7-3에서 보듯 Inter-Operation Parallelism이 나타날 때, 소비자 서버 집합은 from 절에 테이블 큐를 참조하는 서브(Sub) SQL을 가지고 작업을 수행한다.

#### 병렬 실행 계획에서 생산자와 소비자 식별

아래는 앞서 본 쿼리에 대한 실행 계획이다. 10g 이후부터는 이처럼 생산자에 PX SEND, 소비자에 PX RECEIVE가 표시되므로 테이블 큐를 통한 데이터 분배 과정을 좀 더 쉽게 확인할 수 있다.

![](/assets/images/sqlp/sqlp2-07-01-3-EP1.png)

각 오퍼레이션이 어떤 서버 집합에 속한 병렬 프로세스에 의해 수행되는지는 'TQ' 컬럼에 보이는 서버 집합 식별자를 통해 확인할 수 있다.

1. QC가 dept 테이블을 읽어 첫 번째 서버 집합(Q1,01)에게 전송한다.
2. 이어서 첫 번째 서버 집합(Q1,01)은 emp 테이블을 병렬로 읽으면서 앞서 QC에게서 받아둔 dept 테이블과 조인한다. 조인에 성공한 레코드는 바로 두 번째 서버 집합(Q1,02)에게 전송한다.
3. 마지막으로, 두 번째 서버 집합(Q1,02)은 전송받은 레코드를 정렬하고 나서 QC에게 전송한다.

생산자로부터 소비자로 데이터 재분배가 일어날 때마다 'Name' 컬럼에 테이블 큐(:TQxxxx 형태)가 표시된다.

#### (4) IN-OUT 오퍼레이션

아래 병렬 쿼리 실행 계획(9)을 보면, 뒤에서 두 번째 컬럼에 테이블 큐를 통한 IN-OUT 오퍼레이션 정보가 출력되는 것을 볼 수 있다.

![](/assets/images/sqlp/sqlp2-07-01-4-EP1.png)

이는 `plan_table`을 쿼리할 때 `other_tag` 컬럼에서 가져온 것이며, 병렬 쿼리를 이해하는 데 매우 중요한 정보를 제공한다. 각각의 의미를 살펴보자.

#### S→P: PARALLEL_FROM_SERIAL

위 실행 계획에서 9번 오퍼레이션이 여기에 해당하며, QC가 읽은 데이터를 테이블 큐를 통해 병렬 서버 프로세스에게 전송하는 것이다. 맨 우측 `PQ Distrib` 컬럼에 'BROADCAST'라고 표시된 것의 의미는 다음 항목(데이터 재분배)에서 자세히 설명할 것이다.

#### P→S: PARALLEL_TO_SERIAL

위 실행 계획에서 1번 오퍼레이션이 여기에 해당하며, 각 병렬 서버 프로세스가 처리한 데이터를 QC에게 전송하는 것을 의미한다. 병렬 프로세스로부터 QC로 통신이 발생하므로 Inter-Operation Parallelism에 속한다. 참고로, S→P도 통신이 발생하지만(QC로부터 병렬 프로세스로) 이는 병렬 오퍼레이션이 아니므로 Inter-Operation Parallelism에 속하지 않는다.

맨 우측 `PQ Distrib` 컬럼에 'QC (ORDER)'라고 표시된 것은 QC에게 결과 데이터를 전송할 때 첫 번째 병렬 프로세스로부터 마지막 병렬 프로세스까지 순서대로 진행함을 의미하며, SQL이 `ORDER BY` 절을 포함할 때 나타난다. 참고로, `ORDER BY`가 없을 때는 'QC (RANDOM)'이라고 표시되며 병렬 프로세스들이 무순위로(작업이 끝나는 순서대로) QC에게 데이터를 전송함을 뜻한다.

#### P→P: PARALLEL_TO_PARALLEL

데이터를 재분배하는 오퍼레이션으로서, 위 실행 계획에서 2번 단계가 여기에 속한다. 기억할 것은, 실행 계획에 P→P가 나타날 때면 해당 오퍼레이션을 두 개의 서버 집합(Server Set)이 처리한다는 사실이다. 따라서 사용자가 지정한 병렬도의 2배수만큼 병렬 프로세스가 필요하다.

데이터를 정렬(`ORDER BY`) 또는 그룹핑(`GROUP BY`)하거나 조인을 위해 동적으로 파티셔닝할 때 사용되며, 첫 번째 병렬 서버 집합이 읽거나 가공한 데이터를 두 번째 병렬 서버 집합에 전송하는 과정에서 병렬 프로세스 간 통신이 발생하므로 Inter-Operation Parallelism에 속한다. 위 실행 계획에서 2번 오퍼레이션 `PQ Distrib` 컬럼에 'RANGE'라고 표시된 것의 의미는 다음 항목(데이터 재분배)에서 자세히 설명할 것이다.

#### PCWP: PARALLEL_COMBINED_WITH_PARENT

위 실행 계획에서 4~8번 오퍼레이션이 여기에 해당하는데, 이는 한 서버 집합이 현재 스텝과 그 부모(Parent) 스텝을 모두 처리함을 의미한다. 예를 들어, 위 실행 계획의 8-7-4-3번 순으로 이어지는 계층 구조 상에서 `주문_IDX1` 인덱스를 스캔(7~8번 스텝)하면서 `주문` 테이블을 액세스(3번 스텝)하는 일련의 오퍼레이션을 한 서버 집합이 처리한다는 뜻이다.

PCWP도 분명히 병렬 오퍼레이션이지만 한 서버 집합 내에서는 프로세스 간 통신이 발생하지 않으므로 Intra-Operation Parallelism에 속한다. 즉, 한 서버 집합에 속한 서버 프로세스들이 각자 맡은 범위 내에서 두 스텝 이상의 오퍼레이션을 처리하는 것이며, 자식 스텝의 처리 결과를 부모 스텝에서 사용할 뿐 프로세스 간 통신은 필요치 않다.

#### PCWC: PARALLEL_COMBINED_WITH_CHILD

위 실행 계획에서 3번 오퍼레이션이 여기에 해당하며, 한 서버 집합이 현재 스텝과 그 자식(Child) 스텝을 모두 처리함을 의미한다. PCWC도 병렬 오퍼레이션이지만 한 서버 집합 내에서는 프로세스 간 통신이 절대 발생하지 않으므로 Intra-Operation Parallelism에 속한다. 자식 스텝의 처리 결과를 받아 현재 스텝의 입력값으로 사용할 뿐이며, 프로세스 간 통신은 필요치 않다.

참고로, 앞서 본 실행 계획의 뒤에서 두 번째 컬럼(-oL)이 공백(Blank)일 때는 Serial 방식으로 처리됨을 의미하며, 맨 아래쪽 오퍼레이션(0=10)이 여기에 해당한다.

지금까지 설명한 IN-OUT 오퍼레이션에 대해 정리해보자.

- S→P, P→S, P→P는 프로세스 간 통신이 발생한다.
- PCWP와 PCWC는 프로세스 간 통신이 발생하지 않으며, 각 병렬 서버가 독립적으로 여러 스텝을 처리할 때 나타난다. 하위 스텝의 출력값이 상위 스텝의 입력값으로 사용된다.
- P→P, P→S, PCWP, PCWC는 병렬 오퍼레이션인 반면, S→P는 직렬(Serial) 오퍼레이션이다.

병렬 쿼리 실행 계획에 S→P가 나타난다면 해당 오퍼레이션이 병목 지점인지의심해볼 필요가 있다. 만약 처리할 데이터 양이 수백 MB 이상이라면 병렬 오퍼레이션으로 바꾸는 것을 고려해야 한다.
