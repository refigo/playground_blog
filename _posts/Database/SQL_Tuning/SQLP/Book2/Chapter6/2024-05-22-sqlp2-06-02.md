---
title: <오라클 성능 고도화 원리와 해법2> Ch06-02 파티션 Pruning
date: 2024-05-22
categories: [Database, SQL Tuning]
tags: [SQLP]
---

## 오라클 성능 고도화 원리와 해법2 - Ch06-02 파티션 Pruning

'Prune'은 '쓸데없는 가지를 치다', '불필요한 부분을 제거하다'라는 뜻이다. 용어에서 알 수 있듯이, 파티션 프루닝(Pruning)은 하드 파싱이나 실행 시점에 SQL 조건절을 분석하여 읽지 않아도 되는 파티션 세그먼트를 액세스 대상에서 제외시키는 기능이다. 파티션 테이블에 대한 쿼리나 DML을 수행할 때 극적인 성능 개선을 가져다주는 핵심 원리가 파티션 프루닝에 있다.

기본 파티션 프루닝 기법을 먼저 설명하고, 고급 파티션 프루닝 기법으로서 서브쿼리 프루닝(Subquery Pruning)과 조인 필터 프루닝(Join Filter Pruning)을 이어서 설명한다.

### (1) 기본 파티션 프루닝

기본 파티션 프루닝 기법으로는 아래 두 가지가 있다.

- 정적(Static) 파티션 프루닝: 파티션 키 컬럼을 상수 조건으로 조회하는 경우에 작동하며, 액세스할 파티션이 쿼리 최적화 시점에 미리 결정되는 것이 특징이다. 실행 계획의 pstart (partition start)와 pstop (partition stop) 컬럼에는 액세스할 파티션 번호가 출력된다.
- 동적(Dynamic) 파티션 프루닝: 파티션 키 컬럼을 바인드 변수로 조회하면 쿼리 최적화 시점에는 액세스할 파티션을 미리 결정할 수 없다. 실행 시점이 돼서야 사용자가 입력한 값에 따라 결정되며, 실행 계획의 pstart와 pstop 컬럼에는 'KEY'라고 표시된다. NL 조인할 때도 Inner 테이블이 조인 컬럼 기준으로 파티셔닝돼 있다면 동적 프루닝이 작동한다.

#### 동적 파티션 프루닝 시 테이블 레벨 통계 사용

바인드 변수를 사용하면 최적화 시점에 파티션을 확정할 수 없어 동적 파티션 프루닝이 일어난다. 같은 이유로 쿼리 최적화에 테이블 레벨 통계가 사용된다. 반면, 정적 파티션 프루닝일 때는 파티션 레벨 통계가 사용된다.

테이블 레벨 통계는 파티션 레벨 통계보다 다소 부정확하기 때문에 옵티마이저가 가끔 잘못된 실행 계획을 수립하는 경우가 생기며, 이는 바인드 변수 때문에 생기는 대표적인 부작용 중 하나다.

### (2) 서브쿼리 Pruning

조인에 사용되는 고급 파티션 프루닝 기법으로는 아래 두 가지가 있다.

- 서브쿼리 프루닝(8i~)
- 조인 필터 프루닝(11g~)

우선 서브쿼리 프루닝부터 살펴보겠다. 아래와 같은 쿼리가 있다고 하자.

```sql
SELECT d.분기, o.주문일자, o.고객ID, o.상품ID, o.주문수량, o.주문금액
FROM 일자 d, 주문 o
WHERE o.주문일자 = d.일자
AND d.분기 >= 'Q20071';
```

NL 조인할 때 Inner 테이블이 조인 컬럼 기준으로 파티셔닝돼 있다면 동적 프루닝이 작동한다고 했다. 주문은 대용량 거래 테이블이므로 주문 일자 기준으로 월별 Range 파티셔닝돼 있을 것이고, 일자 테이블을 드라이빙해 NL 조인하면 분기 >= 'Q20071' 기간에 포함되는 주문 레코드만 읽을 수 있다.

하지만 대용량 주문 테이블을 랜덤 액세스 위주의 NL 방식으로 조인한다면 결코 좋은 성능을 기대하기 어렵다. 그렇다고 해시 조인이나 소트 머지 조인으로 처리하기도 부담스럽다. 2007년 1분기 이후 주문 데이터만 필요한데도 주문 테이블로부터 모든 파티션을 읽어 조인하고 나중에 분기 조건을 필터링해야 하기 때문이다.

이럴 때 오라클은 리커시브 서브쿼리를 이용한 동적 파티션 프루닝을 고려한다. 이른바 '서브쿼리 프루닝'이라고 불리는 메커니즘으로, 위 쿼리에 대해 내부적으로 아래와 같은 서브쿼리가 수행된다. (수행 가능한 쿼리이므로 직접 테스트해보기 바란다.)

```sql
SELECT DISTINCT DBMS_ROWID.rowid_partition('주문', o.rowid)
FROM (SELECT 일자 FROM 일자 WHERE 분기 >= 'Q20071') a
ORDER BY 1;
```

이 쿼리를 수행하면 액세스해야 할 파티션 번호 목록이 구해지며, 이를 이용해 필요한 주문 파티션만 스캔할 수 있다.

이 방식으로 파티션을 프루닝하려면 드라이빙 테이블을 한 번 더 읽게 되므로 경우에 따라 총 비용이 오히려 증가할 수 있다. 따라서 서브쿼리 프루닝 적용 여부는 옵티마이저가 비용을 고려해 내부적으로 결정한다. 옵티마이저 결정에 영향을 미치는 히든 파라미터는 아래와 같다.

![](/assets/images/sqlp/sqlp2-06-02-2-table1.png)

제거될 것으로 예상되는 파티션 개수가 상당히 많고(기본값에 의하면 50%), where 조건절을 가진 드라이빙 테이블이 파티션 테이블에 비해 상당히 작을 때만 서브쿼리 프루닝이 작동한다.

참고로, 아래와 같이 설정하면 옵티마이저에 의해 계산된 비용과 상관없이 항상 서브쿼리 프루닝을 실시한다.

- `_subquery_pruning_cost_factor = 1`
- `_subquery_pruning_reduction = 10`
