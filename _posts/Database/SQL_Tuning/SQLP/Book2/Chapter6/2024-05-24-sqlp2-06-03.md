---
title: <오라클 성능 고도화 원리와 해법2> Ch06-03 인덱스 파티셔닝
date: 2024-05-24
categories: [Database, SQL Tuning]
tags: [SQLP]
---

## 오라클 성능 고도화 원리와 해법2 - Ch06-03 인덱스 파티셔닝

### (1) 인덱스 파티션 유형

테이블 파티셔닝에 대해 살펴봤고, 이제는 인덱스 파티셔닝에 대해 설명하려고 한다. 인덱스 파티셔닝은 테이블 파티셔닝과 맞물려 다양한 구성이 존재한다. 따라서 테이블을 다음과 같이 구분하고서 인덱스 파티션 유형에 대한 설명을 시작해야 한다.

- 비파티션 테이블 (Non-Partitioned Table)
- 파티션 테이블 (Partitioned Table)

인덱스도 테이블처럼 파티션 여부에 따라 비파티션 인덱스와 파티션 인덱스로 나뉘며, 파티션 인덱스는 각 인덱스 파티션이 담당하는 테이블 파티션 범위에 따라 글로벌과 로컬로 나뉜다.

- 비파티션 인덱스 (Non-Partitioned Index)
- 글로벌 파티션 인덱스 (Global Partitioned Index)
- 로컬 파티션 인덱스 (Local Partitioned Index)

뒤에서 다시 설명하겠지만 로컬 파티션 인덱스는 각 테이블 파티션과 인덱스 파티션이 서로 1:1 대응 관계가 되도록 오라클이 자동으로 관리하는 파티션 인덱스를 말한다. 로컬이 아닌 파티션 인덱스는 모두 글로벌 파티션 인덱스에 속하며, 테이블 파티션과 독립적인 구성(파티션 키, 파티션 기준 값)을 갖는다.

참고로, 인덱스를 글로벌과 로컬로 먼저 나누고, 글로벌을 다시 파티션과 비파티션으로 나누는 분류 방식도 있다. 이때는 비파티션 인덱스를 '글로벌 비파티션 인덱스 (Global Non-Partitioned Index)'라고 부른다.

이 책에서는 처음 설명한 분류 방식을 사용하지만, 편의상 '글로벌 인덱스 (Global Index)'라고 줄여 부를 때는 비파티션 인덱스와 글로벌 파티션 인덱스를 같이 일컫는 말임을 미리 밝힌다.

- 글로벌 인덱스 = 비파티션 인덱스 + 글로벌 파티션 인덱스

이제 테이블과 인덱스 파티셔닝 구분을 서로 조합해보면 아래와 같은 구성이 생긴다.

![](/assets/images/sqlp/sqlp2-06-03-1-table1.png)

- 비파티션 테이블은 비파티션 인덱스와 글로벌 파티션 인덱스를 가질 수 있다.
- 파티션 테이블은 비파티션 인덱스, 글로벌 파티션 인덱스, 로컬 파티션 인덱스를 가질 수 있다.

참고로, 비파티션 테이블에 대한 비트맵 인덱스는 파티셔닝이 허용되지 않으며, 파티션 테이블에 대한 비트맵 인덱스는 로컬 파티셔닝만 허용된다.

### (2) 로컬 파티션 인덱스

이 장을 시작하면서 테이블 파티션을 계절별로 옷을 관리하는 서랍장에 비유했는데, 로컬 파티션 인덱스(Local Partitioned Index)는 계절별로 별도 색인을 다는 것과 같다. 따라서 각 인덱스 파티션이 테이블 파티션과 1:1 대응 관계를 가지며, 테이블 파티션 속성을 그대로 상속받는다. 파티셔닝을 전제로 하므로 흔히 '로컬 인덱스'라고 줄여서 부른다.

![](/assets/images/sqlp/sqlp2-06-03-2-img6-8.png)

파티션 키를 사용자가 따로 정의하지 않아도 오라클이 자동으로 관리한다는 것이 특징이다. 테이블 파티션과 1:1 관계가 되도록 사용자가 수동으로 인덱스 파티션을 구성하더라도 이를 로컬 파티션 인덱스라고 부르지 않는 이유가 여기에 있다.

로컬 파티션 인덱스는 항상 테이블 파티션과 1:1 관계를 형성하므로 만약 테이블이 결합 파티셔닝(Composite Partitioning)되어 있다면 인덱스도 같은 단위로 파티셔닝된다.

로컬 파티션 인덱스가 갖는 장점은 무엇보다 관리적 편의성에 있다. 테이블 파티션 구성에 변경(drop, exchange, split 등)이 생기더라도 인덱스를 재생성할 필요가 없어 관리 비용이 아주 적다.

### (3) 비파티션 인덱스

비파티션 인덱스(Non-Partitioned Index)는 말 그대로 파티셔닝하지 않은 인덱스를 말한다. 테이블이 파티셔닝돼있다면 그림 6-9에서 보듯이 1:M 관계에 놓인다. 즉, 하나의 인덱스 세그먼트가 여러 테이블 파티션 세그먼트와 관계를 갖는다. 그런 의미에서 비파티션 인덱스를 '글로벌 비파티션 인덱스'라고 부르기도 한다.

![](/assets/images/sqlp/sqlp2-06-03-3-img6-9.png)

### (4) 글로벌 파티션 인덱스

글로벌 파티션 인덱스(Global Partitioned Index)는 그림 6-10에서 보는 것처럼 테이블 파티션과 독립적인 구성을 갖도록 파티셔닝하는 것을 말한다. 테이블은 파티셔닝돼있지 않을 수도 있다.

![](/assets/images/sqlp/sqlp2-06-03-3-img6-10.png)

독립적 구성이라는 점에서 효용성이 높을 것처럼 보이지만, 몇몇 제약 사항 때문에 오히려 효용성이 낮은 편이다. 글로벌 파티션 인덱스 사용을 불편하게 만드는 가장 큰 제약은 기준 테이블의 파티션 구성에 변경(drop, exchange, split 등)이 생길 때마다 인덱스가 unusable 상태로 바뀌고 그때마다 인덱스를 재생성해야 한다는 것이다. 이 제약은 비파티션 인덱스일 때도 똑같이 나타난다.

9i부터는 아래와 같이 `update global indexes` 옵션을 주면 파티션 DDL 작업에 의해 영향을 받는 인덱스 레코드를 자동으로 갱신해주므로 인덱스가 unusable 상태로 빠지지 않는다.

```sql
ALTER TABLE ...
SPLIT PARTITION ...
UPDATE GLOBAL INDEXES;
```

하지만, 파티션 DDL로 인해 영향을 받는 레코드가 전체의 5% 미만일 때만 유용하다. 다시 말해, 5% 이상일 때는 인덱스를 재생성하는 것보다 오히려 늦다는 뜻이다. (항상 들어맞는 수치는 아니며, 평균적으로 그렇다는 것이다. 인덱스 손익분기점과 같은 개념으로 이해하면 된다.)

#### 테이블 파티션과의 관계

"오라클이 자동으로 관리해주는 1:1 관계"가 아닌 파티션 인덱스는 모두 글로벌 파티션 인덱스라고 설명했다.

인덱스를 테이블 파티션과 같은 키 컬럼으로 글로벌 파티셔닝한다면 파티션 기준값을 어떻게 정의하느냐에 따라 1:M, M:1, M:M 관계가 모두 가능하다. 그렇더라도 본질적인 관계는 M:M으로 이해해야 한다. 즉, 하나의 인덱스 파티션이 여러 테이블 파티션과 관계를 갖고, 반대로 하나의 테이블 파티션이 여러 인덱스 파티션과 관계를 갖는다. M:M은 다른 모든 관계를 포함한다는 사실을 상기하기 바란다.

참고로, 로컬 파티션 인덱스(그림 6-8)처럼 테이블과 1:1 관계가 되도록 수동으로 구성하더라도 여느 글로벌 파티션과 마찬가지로 기준 테이블 구성에 변경이 발생할 때마다 인덱스를 재생성해야 한다.

인덱스를 테이블 파티션과 다른 키 컬럼으로 글로벌 파티셔닝할 수도 있는데, 예를 들어 테이블은 주문일자, 인덱스는 배송일자에 따라 파티셔닝할 수 있다. 이때는 테이블 파티션과 인덱스 파티션 간에는 항상 M:M 관계가 형성된다.

#### 글로벌 해시 파티션 인덱스

글로벌 파티션 인덱스의 경우, 9i까지는 글로벌 Range 파티션만 가능했지만 10g부터는 글로벌 해시 파티션도 가능해졌다. 즉, 테이블과 독립적으로 인덱스만 해시 키 값에 따라 파티셔닝할 수 있게 되었다. 글로벌 해시 파티션 인덱스는 Right Growing 인덱스처럼 Hot 블록이 발생하는 인덱스의 경합을 분산할 목적으로 주로 사용된다. 글로벌 결합(Composite) 인덱스 파티셔닝은 여전히 불가능하다.

### (5) Prefixed vs. Non-Prefixed

파티션 인덱스를 Prefixed와 Non-Prefixed로 나눌 수 있다. 이는 인덱스 파티션 키 컬럼이 인덱스 구성상 왼쪽 선두 컬럼에 위치하는지에 따른 구분이다.

- Prefixed: 파티션 인덱스를 생성할 때, 파티션 키 컬럼을 인덱스 키 컬럼 왼쪽 선두에 두는 것을 말한다.
- Non-Prefixed: 파티션 인덱스를 생성할 때, 파티션 키 컬럼을 인덱스 키 컬럼 왼쪽 선두에 두지 않는 것을 말한다. 파티션 키가 인덱스 컬럼에 아예 속하지 않을 때도 여기에 속한다.

로컬과 글로벌, Prefixed와 Non-Prefixed를 조합하면 아래 4가지 구성이 나온다.

![](/assets/images/sqlp/sqlp2-06-03-5-table1.png)

글로벌 파티션 인덱스는 Prefixed 파티션만 지원되므로 결과적으로 세 개의 파티션 인덱스가 있고, 비파티션 인덱스를 포함해 아래 네 가지 유형으로 최종 정리할 수 있다.

- 비파티션 인덱스
- 글로벌 Prefixed 파티션 인덱스
- 로컬 Prefixed 파티션 인덱스
- 로컬 Non-Prefixed 파티션 인덱스

### (6) 파티션 인덱스 구성 예시

파티션 인덱스 유형별 구성 예시를 요약하면 아래 표와 같다.

![](/assets/images/sqlp/sqlp2-06-03-6-table1.png)

글로벌 Non-Prefixed 파티션 인덱스는 지원되지 않지만, 지원된다면 아래와 같은 구성일 것이다.

![](/assets/images/sqlp/sqlp2-06-03-6-table2.png)

인덱스 파티셔닝을 공부할 때면 누구나 어렵고 복잡하다고 느낀다. 처음에는 로컬, 글로벌을 구분하기도 쉽지 않은데 여기에 Prefixed, Non-Prefixed 개념까지 더해지니 그럴 수밖에 없다. 이들 구성과 액세스 유형에 따라 성능에 많은 차이가 생기므로, 반드시 넘어야 할 산이라는 각오로 이 기회에 개념과 구조를 정확히 이해하기 바란다.

#### 인덱스 파티셔닝 예제

```sql
SQL> create unique index t_idx1 on t(gubun, seq2) LOCAL;
create unique index t_idx1 on t(gubun, seq2) LOCAL

ERROR at line 1:
ORA-14039: partitioning columns must form a subset of key columns of a UNIQUE index
```

위 `CREATE INDEX` 문에 에러가 발생한 이유가 무엇일까? 뒤에서 다시 설명하겠지만 Unique 파티션 인덱스를 만들 때는 파티션 키 컬럼이 인덱스 컬럼에 포함돼 있어야 하기 때문이다. 방금 생성하려 한 인덱스는 로컬 파티션 인덱스이므로 테이블 파티션 키 컬럼을 상속받아 `seg`가 파티션 키 컬럼인데, 이 컬럼이 인덱스 컬럼에 포함되지 않아 에러가 발생한 것이다.

```sql
CREATE INDEX t_idx4 ON t (seg, name) LOCAL;
```

위 `CREATE INDEX` 문은 로컬 Non-Prefixed 파티션 인덱스를 만드는 예시이다. 로컬 인덱스이므로 파티션 키가 `seg`이지만 이 컬럼이 인덱스 선두에 위치하지 않은 것을 확인하기 바란다. 앞서 생성한 `t_idx2 Unique` 인덱스도 마찬가지다.

지금까지 로컬 파티션 인덱스를 생성하는 예시를 보았고, 이제는 글로벌 파티션 인덱스를 생성해 보자.

방금 보았듯이 로컬 파티션 인덱스에는 Non-Prefixed가 허용되지만 글로벌 파티션 인덱스에는 허용되지 않는다.

인덱스 파티션 키인 `seg`를 인덱스 선두 컬럼에 두었더니 인덱스가 정상적으로 만들어졌다. 글로벌 Prefixed 파티션 인덱스가 생성된 것이다. 위와 같이 테이블 파티션과 같게 정의하더라도 이를 '로컬 파티션 인덱스'라고 부르지 않는다고 설명한 내용을 상기하기 바란다.

### (7) 글로벌 파티션 인덱스의 효용성

결론부터 말하면 글로벌 파티션 인덱스는 경합을 분산시키려고 글로벌 해시 파티셔닝하는 경우 외에는 거의 사용되지 않는 실정이다.

'비파티션 테이블에 대한 글로벌 파티션 인덱스', '파티션 테이블에 대한 글로벌 파티션 인덱스'로 나누어 생각해볼 수 있는데, 전자의 경우 테이블을 파티셔닝하지 않을 정도로 중소형급 테이블이면 굳이 인덱스만을 따로 파티셔닝할 이유는 별로 없다.

후자, 즉 '파티션 테이블에 대한 글로벌 파티션 인덱스'의 효용성은 어떤가? 파티션 테이블에 대해서도 글로벌 파티션 인덱스보다는 로컬 파티션 인덱스와 비파티션 인덱스가 주로 사용되고 있으며, 그 이유를 아래 두 가지로 나누어 살펴보자.

#### 1. 테이블과 같은 컬럼으로 파티셔닝하는 경우

테이블은 날짜 컬럼 기준으로 월별 파티셔닝하고, 인덱스는 분기별 파티셔닝하는 경우를 예로 들어보자. 글로벌 파티션 인덱스에는 Prefixed 파티션만 허용되므로 날짜 컬럼을 선두에 둬야 하는데, 날짜 조건은 대개 범위 검색 조건(between, 부등호)이 사용되므로 인덱스 스캔 효율 면에서 불리하다. 특히 NL 조인에서 Inner 테이블 액세스를 위해 자주 사용되는 인덱스라면 비효율이 더 크게 작용한다.

다른 조건 컬럼을 인덱스 선두에 둘 수 있다는 측면에선 로컬 Non-Prefixed 파티션 인덱스가 훨씬 유리하다.

두 달 이상의 넓은 범위 조건을 가지고 Inner 테이블 액세스를 위해 사용될 때는 로컬 Non-Prefixed 파티션 인덱스에도 비효율이 생긴다. 조인 액세스가 일어나는 레코드마다 여러 인덱스 파티션을 탐색해야 하기 때문이다. 따라서 NL 조인에서 넓은 범위 조건을 가지고 Inner 테이블 액세스를 위해 자주 사용된다면 비파티션 인덱스가 가장 좋은 선택이다.

#### 2. 테이블과 다른 컬럼으로 파티셔닝하는 경우

테이블 파티션 기준인 날짜 이외의 컬럼으로 인덱스를 글로벌 파티셔닝할 수 있는데, (인덱스 경합을 분산하려는 경우가 아니라면) 그런 구성은 대개 인덱스를 적정 크기로 유지하려는 데에 목적이 있다. 인덱스가 너무 커지면 관리하기 힘들고 인덱스 높이(height)가 증가해 액세스 효율도 나빠지기 때문이다.

하지만 그런 장점도 로컬 파티션 인덱스 때문에 무색해진다. 글로벌 파티션이 비파티션보다 관리상 이점이 있다고는 하나 로컬 파티션만 못하고, 인덱스 높이 조절 측면에서도 그렇다.
