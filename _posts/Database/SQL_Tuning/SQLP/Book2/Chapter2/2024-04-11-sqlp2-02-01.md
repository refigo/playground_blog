---
title: <오라클 성능 고도화 원리와 해법2> Ch02-01 Nested Loops 조인
date: 2024-04-11
categories: [Database, SQL Tuning]
tags: [SQLP]
---

본서는 SQL 기초를 다루는 책이 아니므로 조인의 기본 개념은 설명하지 않는다. 오라클이 내부적으로 어떻게 조인을 수행하는지 원리를 설명하고, 그런 원리를 바탕으로 어떻게 쿼리 수행 성능을 향상시킬지 활용점을 밝히는 데 집중할 것이다.

## 오라클 성능 고도화 원리와 해법2 - Ch02-01 Nested Loops 조인

### (1) 기본 메커니즘

프로그래밍을 해 본 독자라면 누구나 아래 중첩 루프문(Nested Loop)의 수행 구조를 이해할 것이고, 그렇다면 Nested Loops 조인(이하 NL 조인)도 어렵지 않게 이해할 수 있다.

```java
< C, JAVA >
for (i=0; i<100; i++){    // -- outer loop
    for(j=0; j<100; j++){ // -- inner loop
	    // Do Anything ...
    }
}

< PL/SQL >
for outer in 1..100 loop
    for inner in 1..100 loop
        dbms_output.put_line(outer || ' : ' || inner);
    end loop;
end loop;
```

위 중첩 루프문과 같은 수행 구조를 사용하는 NL 조인이 실제 어떤 순서로 데이터를 액세스하는지 아래 PL/SQL문이 잘 설명해준다(스크립트 ch2.01.kt 참조).

```plsql
begin
    for outer in (select deptno, empno, rpad(ename, 10) ename from emp)
    loop -- outer 루프
        for inner in (select dname from dept where deptno = outer.deptno)
        loop -- inner 루프
            dbms_output.put_line(outer.empno || ': ' || outer.ename || ' : ' || inner.dname);
        end loop;
    end loop;
end;
```

위 PL/SQL문은 아래 쿼리와 100% 같은 순서로 데이터를 액세스하고, 데이터 출력 순서도 같다. 내부적으로 (= Recursive하게) 쿼리를 반복 수행하지 않는다는 점만 다르다.

```sql
select /*+ ordered use_nl (d) */ e.empno, e.ename, d.dname
from emp e, dept d
where d.deptno = e.deptno;
```

사실 뒤에서 설명하는 소트머지 조인과 해시 조인도 각각 Sort Area와 Hash Area에 가공한 데이터를 이용한다는 점만 다를 뿐 기본적인 조인 프로세싱은 다르지 않다.

### (2) 힌트를 이용해 NL 조인을 제어하는 방법

```sql
select /*+ ordered use_nl(e) */ *
from dept d, emp e
where e.deptno = d.deptno
```

ordered 힌트는 from 절에 기술된 순서대로 조인하라고 옵티마이저에게 지시할 때 사용하고, use_nl 힌트는 NL 방식으로 조인하라고 지시할 때 사용한다. 위에서는 ordered와 use_nl(e) 힌트를 같이 사용했으므로 dept 테이블(Outer 테이블)을 기준으로 emp 테이블(Inner 테이블)과 조인할 때 NL 방식으로 조인하라는 뜻이 된다.

| Outer 테이블, Inner 테이블                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| 조인을 설명하려면 우선 Outer와 Inner에 대한 용어 정의를 명확히 할 필요가 있다.<br><br>우선, Outer와 Inner라는 용어가 Outer 조인에 사용되는 두 테이블을 지칭할 때만 사용하는 것이 아님을 이해하기 바란다.<br><br>그런데 트레이스 파일에 사용된 용어가 표준 용어는 아니므로 크게 혼란스러워할 필요는 없다. 이벤트 트레이스는 오라클 개발자들이 디버깅 용도로 개발해 사용되어온 것이고, 가장 오래된 NL 조인의 틀에 맞추다 보니 그렇게 된 것이라고 이해하면 된다.<br><br>본서에서는 아래와 같이 정의하고 설명을 진행하기로 하겠다.<br><br>참고로, 해시 조인에서도 Build Input을 드라이빙(Drving) 테이블이라고 표현하기도 하지만 소트머지 조인에서는 그런 표현을 쓰지 않는다. |

위에서는 두 개 테이블을 조인하고 있지만 세 개 이상을 조인할 때는 힌트를 아래처럼 사용하는 것이 올바른 사용법이다.

```sql
select /*+ ordered use_nl(B) use_nl(C) use_hash(D) */ *
from A, B, C, D
where ......
```

아래는 ordered나 leading 힌트를 기술하지 않았으므로 네 개 테이블을 NL 방식으로 조인하되 순서는 옵티마이저가 스스로 정하도록 맡기는 것이다.

```sql
select /*+ use_nl(A, B, C, D) */ *
from A, B, C, D
Where ......
```

### (3) NL 조인 수행 과정 분석

자! 이제 NL 조인의 기본 알고리즘과 이를 제어하는 힌트 사용법까지 이해했다.

여기서 기억할 것은, 각 단계를 완료하고 나서 다음 단계로 넘어가는 게 아니라 한 레코드씩 순차적으로 진행한다는 사실이다. 단, orderby는 전체 집합을 대상으로 정렬해야 하므로 작업을 모두 완료한 후에 다음 오퍼레이션을 진행한다.

그림2-2를 보고나면 NL 조인의 수행 절차를 좀 더 명확히 이해할 수 있다.

![](/assets/images/sqlp/sqlp2-02-01-3-img2-2.png)

OLTP 시스템에서 조인을 튜닝할 때는 일차적으로 NL 조인부터 고려하는 것이 올바른 순서다. 우선, NL 조인의 기본 메커니즘을 따라 각 단계의 수행 일량을 분석해 과도한 Random 액세스가 발생하는 지점을 파악한다. 조인 순서를 변경해 Random 액세스 발생량을 줄일 수 있는 경우가 있고, 그렇지 못할 때는 인덱스 컬럼 구성을 변경하거나 다른 인덱스의 사용을 고려해야 한다.

여러 가지 방안을 검토한 결과 NL 조인이 효과적이지 못하다고 판단될 때 해시 조인이나 소트 머지 조인을 검토한다.

### (4) NL 조인의 특징

오라클은 블록 단위로 I/O를 수행하며, 하나의 레코드를 읽으려고 블록을 통째로 읽는 Random 액세스 방식은 설령 메모리 버퍼에서 빠르게 읽더라도 비효율이 존재한다. 그런데 NL 조인의 첫 번째 특징이 Random 액세스 위주의 조인 방식이라는 점이다. 따라서 인덱스 구성이 아무리 완벽하더라도 대량의 데이터를 조인할 때 매우 비효율적이다.

두 번째 특징은, 조인을 한 레코드씩 순차적으로 진행한다는 점이다. 첫 번째 특징 때문에 대용량 데이터 처리시 매우 치명적인 한계를 드러내지만, 반대로 이 두 번째 특징 때문에 아무리 대용량 집합이더라도 매우 극적인 응답 속도를 낼 수 있다. 부분 범위 처리가 가능한 상황에서 그렇다. 그리고 순차적으로 진행하는 특징 때문에 먼저 액세스되는 테이블의 처리 범위에 의해 전체 일량이 결정된다.

다른 조인 방식과 비교했을 때 인덱스 구성 전략이 특히 중요하다는 것도 NL 조인의 중요한 특징이다. 조인 컬럼에 대한 인덱스가 있는지 없느냐, 있다면 컬럼이 어떻게 구성됐느냐에 따라 조인 효율이 크게 달라진다.

이런 여러 가지 특징을 종합할 때, NL 조인은 소량의 데이터를 주로 처리하거나 부분 범위 처리가 가능한 온라인 트랜잭션 환경에 적합한 조인 방식이라고 할 수 있다.

### (5) NL 조인 튜닝 실습

지금부터 SQL 트레이스 분석을 통해 실제 튜닝하는 과정을 실습해 보자.

jobs_max_sal_ix 인덱스를 스캔하고서 jobs 테이블을 액세스한 횟수가 278인데, 테이블에서 job_type='A' 조건을 필터링한 결과는 3건에 그친다. 불필요한 테이블 액세스를 많이 한 셈이고, 이처럼 테이블을 액세스한 후에 필터링되는 비율이 높다면 인덱스에 테이블 필터 조건 컬럼을 추가하는 것을 고려해볼 필요가 있다.

jobs_max_sal_ix 인덱스에 job_type 컬럼을 추가하고서 트레이스를 다시 확인해보니 아래와 같이 불필요한 테이블 액세스가 없어졌다.

Rows에 표시된 숫자만 보면 비효율적인 액세스가 없어 보이지만 테이블을 액세스하기 전 인덱스 스캔 단계에서의 일량을 확인하지 못했으므로 튜닝이 끝났다고 볼 수 없다.

여기서 보면 jobs_max_sal_ix 인덱스로부터 3건을 리턴하기 위해 인덱스 블록을 1,000 개 읽은 것을 알 수 있다.

튜닝 방법은? jobs_max_sal_ix 인덱스 컬럼 순서를 조정해 [job_type + max_salary] 순 으로 구성해 주면 된다. (물론 다른 쿼리에 미치는 '영향도 분석' 이 선행 되어야한다.)

문제는 jobs 테이블을 읽고나서 employees 테이블과의 조인 시도 횟수다. 1,278번 조인 시도를 했지만 최종적으로 조인에 성공한 결과 집합은 5건 뿐이다.

이럴 때는 조인 순서를 바꾸는 것을 고려해볼 수 있다. 만약 hiredate 조건절에 부합하는 레코드가 별로 없다면 튜닝에 성공할 가능성이 높다.

하지만 그 반대의 결과가 나타날 수도 있다. 위에서 employees와 조인 후에 5건으로 줄어든 것은 jobs로부터 넘겨받는 job id와 hire_date 두 컬럼을 조합했을 때 그런 것이지 hire_date 단독으로 조회했을 때는 데이터량이 생각보다 많을 수 있기 때문이다.

조인 순서를 바꾸어도 별 소득이 없다면 2절과 3절에서 설명할 소트머지 조인과 해시 조인을 검토해봐야 한다.
